---
date: 2018-03-03
title: "Keep trying that api call with purrr::possibly()"
tags: [R]
menu:
  main:
    parent: Blog
    identifier: /blog/api_call
    weight: 2
---



<p>Sometimes you need to call an api to get some result from a web service, but sometimes this call might fail. You might get an error 500 for example, or maybe you’re making too many calls too fast. Regarding this last point, I really encourage you to read <a href="https://towardsdatascience.com/ethics-in-web-scraping-b96b18136f01">Ethics in Web Scraping</a>.</p>
<p>In this blog post I will show you how you can keep trying to make this api call using <code>purrr::possibly()</code>.</p>
<p>For this, let’s use this function that will simulate an api call:</p>
<pre class="r"><code>get_data = function(){
  number = rbinom(1, 1, 0.9)
  ifelse(number == 0, &quot;OK&quot;, stop(&quot;Error: too many calls!&quot;))
}</code></pre>
<p>This function simply returns a random draw from a binomial distribution. If this number equals 0 with probability 0.1, the function returns “OK”, if not, it throws an error. Because the probability of success is only 10%, your api call might be unsuccessful:</p>
<pre class="r"><code>get_data()</code></pre>
<pre><code>Error in ifelse(number == 0, &quot;OK&quot;, stop(&quot;Error: too many calls!&quot;)) :
  Error: too many calls!</code></pre>
<p>How to keep trying until it works? For this, we’re going to use <code>purrr::possibly()</code>; this function takes another function as argument and either returns the result, or another output in case of error, that the user can define:</p>
<pre class="r"><code>possibly_get_data = purrr::possibly(get_data, otherwise = NULL)</code></pre>
<p>Let’s try it:</p>
<pre class="r"><code>set.seed(12)
possibly_get_data()</code></pre>
<pre><code>## NULL</code></pre>
<p>With <code>set.seed(12)</code>, the function returns a number different from 0, and thus throws an error: but because we’re wrapping the function around <code>purrr::possibly()</code>, the function now returns <code>NULL</code>. The first step is done; now we can use this to our advantage:</p>
<pre class="r"><code>definitely_get_data = function(func, n_tries, sleep, ...){

  possibly_func = purrr::possibly(func, otherwise = NULL)

  result = NULL
  try_number = 1

  while(is.null(result) &amp;&amp; try_number &lt;= n_tries){
    print(paste(&quot;Try number: &quot;, try_number))
    try_number = try_number + 1
    result = possibly_func(...)
    Sys.sleep(sleep)
  }

  return(result)
}</code></pre>
<p><code>definitely_get_data()</code> is a function that takes any function as argument, as well as a user provided number of tries (as well as <code>...</code> to pass further arguments to <code>func()</code>). Remember, if <code>func()</code> fails, it will return <code>NULL</code>; the while loop ensures that while the result is <code>NULL</code>, and the number of tries is below what you provided, the function will keep getting called. I didn’t talk about <code>sleep</code>; this argument is provided to <code>Sys.sleep()</code> which introduces a break between calls that is equal to <code>sleep</code> seconds. This ensures you don’t make too many calls too fast. Let’s try it out:</p>
<pre class="r"><code>set.seed(123)
definitely_get_data(get_data, 10, 1)</code></pre>
<pre><code>## [1] &quot;Try number:  1&quot;
## [1] &quot;Try number:  2&quot;
## [1] &quot;Try number:  3&quot;
## [1] &quot;Try number:  4&quot;
## [1] &quot;Try number:  5&quot;</code></pre>
<pre><code>## [1] &quot;OK&quot;</code></pre>
<p>It took 5 tries to get the result! However, if after 10 tries <code>get_data()</code> fails to return what you need it will stop (but you can increase the number of tries…).</p>
<p>If you found this blog post useful, you might want to follow me on <a href="https://www.twitter.com/brodriguesco">twitter</a> for blog post updates.</p>
