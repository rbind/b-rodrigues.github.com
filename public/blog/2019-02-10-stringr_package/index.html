<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>Manipulating strings with the {stringr} package</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	
</head>
<body>
	<header>
<link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet">
<pre>
<a class="nav-link" href="/index.html">Econometrics and Free Software</a> by <a class="nav-link" href="/about/me">Bruno Rodrigues</a>.
<a href="https://www.brodrigues.co/blog/index.xml">RSS feed for blog post updates</a>.
Follow me on <a rel="me" href="https://fosstodon.org/@brodriguesco">Mastodon</a>, <a href="https://twitter.com/brodriguesco" rel="nofollow">twitter</a>, or check out my <a href="https://github.com/b-rodrigues">Github</a>.
Check out my package that adds logging to R functions, <a href="https://b-rodrigues.github.io/chronicler/">{chronicler}</a>.
Or read my free ebooks, <a href="https://www.brodrigues.co/about/books/">to learn some R and build reproducible analytical pipelines.</a>.
You can also watch my <a href="https://www.youtube.com/user/cbrunos" rel="nofollow">youtube</a> channel or find the slides to the talks I've given <a href="https://www.brodrigues.co/about/talks/">here</a>.
<a href="https://www.buymeacoffee.com/brodriguesco" rel="nofollow">Buy me a coffee</a>, my kids don't let me sleep.
</pre>
</header>

	
	<main>
		<article>
			<h1>Manipulating strings with the {stringr} package</h1>
			<b><time>2019/02/10</time></b>
		       
		           <a href="/tags/r">R</a>
        	       

			<div>
				<div style="text-align:center;">
<p><a href="https://b-rodrigues.github.io/modern_R/descriptive-statistics-and-data-manipulation.html#manipulate-strings-with-stringr">
<img src="/img/string.jpg" title = "Click here to go the ebook"></a></p>
</div>
<p>This blog post is an excerpt of my ebook Modern R with the tidyverse that you can read for
free <a href="https://b-rodrigues.github.io/modern_R/">here</a>. This is taken from Chapter 4,
in which I introduce the <code>{stringr}</code> package.</p>
<div id="manipulate-strings-with-stringr" class="section level2">
<h2>Manipulate strings with <code>{stringr}</code></h2>
<p><code>{stringr}</code> contains functions to manipulate strings. In Chapter 10, I will teach you about regular
expressions, but the functions contained in <code>{stringr}</code> allow you to already do a lot of work on
strings, without needing to be a regular expression expert.</p>
<p>I will discuss the most common string operations: detecting, locating, matching, searching and
replacing, and exctracting/removing strings.</p>
<p>To introduce these operations, let us use an ALTO file of an issue of <em>The Winchester News</em> from
October 31, 1910, which you can find on this
<a href="https://gist.githubusercontent.com/b-rodrigues/5139560e7d0f2ecebe5da1df3629e015/raw/e3031d894ffb97217ddbad1ade1b307c9937d2c8/gistfile1.txt">link</a> (to see
how the newspaper looked like,
<a href="https://chroniclingamerica.loc.gov/lccn/sn86069133/1910-10-31/ed-1/seq-1/">click here</a>). I re-hosted
the file on a public gist for archiving purposes. While working on the book, the original site went
down several times…</p>
<p>ALTO is an XML schema for the description of text OCR and layout information of pages for digitzed
material, such as newspapers (source: <a href="https://en.wikipedia.org/wiki/ALTO_(XML)">ALTO Wikipedia page</a>).
For more details, you can read my
<a href="https://www.brodrigues.co/blog/2019-01-13-newspapers_mets_alto/">blogpost</a>
on the matter, but for our current purposes, it is enough to know that the file contains the text
of newspaper articles. The file looks like this:</p>
<pre><code>&lt;TextLine HEIGHT=&quot;138.0&quot; WIDTH=&quot;2434.0&quot; HPOS=&quot;4056.0&quot; VPOS=&quot;5814.0&quot;&gt;
&lt;String STYLEREFS=&quot;ID7&quot; HEIGHT=&quot;108.0&quot; WIDTH=&quot;393.0&quot; HPOS=&quot;4056.0&quot; VPOS=&quot;5838.0&quot; CONTENT=&quot;timore&quot; WC=&quot;0.82539684&quot;&gt;
&lt;ALTERNATIVE&gt;timole&lt;/ALTERNATIVE&gt;
&lt;ALTERNATIVE&gt;tlnldre&lt;/ALTERNATIVE&gt;
&lt;ALTERNATIVE&gt;timor&lt;/ALTERNATIVE&gt;
&lt;ALTERNATIVE&gt;insole&lt;/ALTERNATIVE&gt;
&lt;ALTERNATIVE&gt;landed&lt;/ALTERNATIVE&gt;
&lt;/String&gt;
&lt;SP WIDTH=&quot;74.0&quot; HPOS=&quot;4449.0&quot; VPOS=&quot;5838.0&quot;/&gt;
&lt;String STYLEREFS=&quot;ID7&quot; HEIGHT=&quot;105.0&quot; WIDTH=&quot;432.0&quot; HPOS=&quot;4524.0&quot; VPOS=&quot;5847.0&quot; CONTENT=&quot;market&quot; WC=&quot;0.95238096&quot;/&gt;
&lt;SP WIDTH=&quot;116.0&quot; HPOS=&quot;4956.0&quot; VPOS=&quot;5847.0&quot;/&gt;
&lt;String STYLEREFS=&quot;ID7&quot; HEIGHT=&quot;69.0&quot; WIDTH=&quot;138.0&quot; HPOS=&quot;5073.0&quot; VPOS=&quot;5883.0&quot; CONTENT=&quot;as&quot; WC=&quot;0.96825397&quot;/&gt;
&lt;SP WIDTH=&quot;74.0&quot; HPOS=&quot;5211.0&quot; VPOS=&quot;5883.0&quot;/&gt;
&lt;String STYLEREFS=&quot;ID7&quot; HEIGHT=&quot;69.0&quot; WIDTH=&quot;285.0&quot; HPOS=&quot;5286.0&quot; VPOS=&quot;5877.0&quot; CONTENT=&quot;were&quot; WC=&quot;1.0&quot;&gt;
&lt;ALTERNATIVE&gt;verc&lt;/ALTERNATIVE&gt;
&lt;ALTERNATIVE&gt;veer&lt;/ALTERNATIVE&gt;
&lt;/String&gt;
&lt;SP WIDTH=&quot;68.0&quot; HPOS=&quot;5571.0&quot; VPOS=&quot;5877.0&quot;/&gt;
&lt;String STYLEREFS=&quot;ID7&quot; HEIGHT=&quot;111.0&quot; WIDTH=&quot;147.0&quot; HPOS=&quot;5640.0&quot; VPOS=&quot;5838.0&quot; CONTENT=&quot;all&quot; WC=&quot;1.0&quot;/&gt;
&lt;SP WIDTH=&quot;83.0&quot; HPOS=&quot;5787.0&quot; VPOS=&quot;5838.0&quot;/&gt;
&lt;String STYLEREFS=&quot;ID7&quot; HEIGHT=&quot;111.0&quot; WIDTH=&quot;183.0&quot; HPOS=&quot;5871.0&quot; VPOS=&quot;5835.0&quot; CONTENT=&quot;the&quot; WC=&quot;0.95238096&quot;&gt;
&lt;ALTERNATIVE&gt;tll&lt;/ALTERNATIVE&gt;
&lt;ALTERNATIVE&gt;Cu&lt;/ALTERNATIVE&gt;
&lt;ALTERNATIVE&gt;tall&lt;/ALTERNATIVE&gt;
&lt;/String&gt;
&lt;SP WIDTH=&quot;75.0&quot; HPOS=&quot;6054.0&quot; VPOS=&quot;5835.0&quot;/&gt;
&lt;String STYLEREFS=&quot;ID3&quot; HEIGHT=&quot;132.0&quot; WIDTH=&quot;351.0&quot; HPOS=&quot;6129.0&quot; VPOS=&quot;5814.0&quot; CONTENT=&quot;cattle&quot; WC=&quot;0.95238096&quot;/&gt;
&lt;/TextLine&gt;</code></pre>
<p>We are interested in the strings after <code>CONTENT=</code>. We are going to use functions from the <code>{stringr}</code>
package to get the strings after <code>CONTENT=</code>. In Chapter 10, we are going to explore this file
again, but using complex regular expressions to get all the content in one go.</p>
<div id="getting-text-data-into-rstudio" class="section level3">
<h3>Getting text data into Rstudio</h3>
<p>First of all, let us read in the file:</p>
<pre class="r"><code>winchester &lt;- read_lines(&quot;https://gist.githubusercontent.com/b-rodrigues/5139560e7d0f2ecebe5da1df3629e015/raw/e3031d894ffb97217ddbad1ade1b307c9937d2c8/gistfile1.txt&quot;)</code></pre>
<p>Even though the file is an XML file, I still read it in using <code>read_lines()</code> and not <code>read_xml()</code>
from the <code>{xml2}</code> package. This is for the purposes of the current exercise, and also because I
always have trouble with XML files, and prefer to treat them as simple text files, and use regular
expressions to get what I need.</p>
<p>Now that the ALTO file is read in and saved in the <code>winchester</code> variable, you might want to print
the whole thing in the console. Before that, take a look at the structure:</p>
<pre class="r"><code>str(winchester)</code></pre>
<pre><code>##  chr [1:43] &quot;&quot; ...</code></pre>
<p>So the <code>winchester</code> variable is a character atomic vector with 43 elements. So first, we need to
understand what these elements are. Let’s start with the first one:</p>
<pre class="r"><code>winchester[1]</code></pre>
<pre><code>## [1] &quot;&quot;</code></pre>
<p>Ok, so it seems like the first element is part of the header of the file. What about the second one?</p>
<pre class="r"><code>winchester[2]</code></pre>
<pre><code>## [1] &quot;&lt;meta http-equiv=\&quot;Content-Type\&quot; content=\&quot;text/html; charset=UTF-8\&quot;&gt;&lt;base href=\&quot;https://chroniclingamerica.loc.gov/lccn/sn86069133/1910-10-31/ed-1/seq-1/ocr.xml\&quot;&gt;&lt;style&gt;body{margin-left:0;margin-right:0;margin-top:0}#bN015htcoyT__google-cache-hdr{background:#f5f5f5;font:13px arial,sans-serif;text-align:left;color:#202020;border:0;margin:0;border-bottom:1px solid #cecece;line-height:16px;padding:16px 28px 24px 28px}#bN015htcoyT__google-cache-hdr *{display:inline;font:inherit;text-align:inherit;color:inherit;line-height:inherit;background:none;border:0;margin:0;padding:0;letter-spacing:0}#bN015htcoyT__google-cache-hdr a{text-decoration:none;color:#1a0dab}#bN015htcoyT__google-cache-hdr a:hover{text-decoration:underline}#bN015htcoyT__google-cache-hdr a:visited{color:#609}#bN015htcoyT__google-cache-hdr div{display:block;margin-top:4px}#bN015htcoyT__google-cache-hdr b{font-weight:bold;display:inline-block;direction:ltr}&lt;/style&gt;&lt;div id=\&quot;bN015htcoyT__google-cache-hdr\&quot;&gt;&lt;div&gt;&lt;span&gt;This is Google&#39;s cache of &lt;a href=\&quot;https://chroniclingamerica.loc.gov/lccn/sn86069133/1910-10-31/ed-1/seq-1/ocr.xml\&quot;&gt;https://chroniclingamerica.loc.gov/lccn/sn86069133/1910-10-31/ed-1/seq-1/ocr.xml&lt;/a&gt;.&lt;/span&gt;&amp;nbsp;&lt;span&gt;It is a snapshot of the page as it appeared on 21 Jan 2019 05:18:18 GMT.&lt;/span&gt;&amp;nbsp;&lt;span&gt;The &lt;a href=\&quot;https://chroniclingamerica.loc.gov/lccn/sn86069133/1910-10-31/ed-1/seq-1/ocr.xml\&quot;&gt;current page&lt;/a&gt; could have changed in the meantime.&lt;/span&gt;&amp;nbsp;&lt;a href=\&quot;http://support.google.com/websearch/bin/answer.py?hl=en&amp;amp;p=cached&amp;amp;answer=1687222\&quot;&gt;&lt;span&gt;Learn more&lt;/span&gt;.&lt;/a&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=\&quot;display:inline-block;margin-top:8px;margin-right:104px;white-space:nowrap\&quot;&gt;&lt;span style=\&quot;margin-right:28px\&quot;&gt;&lt;span style=\&quot;font-weight:bold\&quot;&gt;Full version&lt;/span&gt;&lt;/span&gt;&lt;span style=\&quot;margin-right:28px\&quot;&gt;&lt;a href=\&quot;http://webcache.googleusercontent.com/search?q=cache:2BVPV8QGj3oJ:https://chroniclingamerica.loc.gov/lccn/sn86069133/1910-10-31/ed-1/seq-1/ocr.xml&amp;amp;hl=en&amp;amp;gl=lu&amp;amp;strip=1&amp;amp;vwsrc=0\&quot;&gt;&lt;span&gt;Text-only version&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span style=\&quot;margin-right:28px\&quot;&gt;&lt;a href=\&quot;http://webcache.googleusercontent.com/search?q=cache:2BVPV8QGj3oJ:https://chroniclingamerica.loc.gov/lccn/sn86069133/1910-10-31/ed-1/seq-1/ocr.xml&amp;amp;hl=en&amp;amp;gl=lu&amp;amp;strip=0&amp;amp;vwsrc=1\&quot;&gt;&lt;span&gt;View source&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;span style=\&quot;display:inline-block;margin-top:8px;color:#717171\&quot;&gt;&lt;span&gt;Tip: To quickly find your search term on this page, press &lt;b&gt;Ctrl+F&lt;/b&gt; or &lt;b&gt;⌘-F&lt;/b&gt; (Mac) and use the find bar.&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=\&quot;position:relative;\&quot;&gt;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;&quot;</code></pre>
<p>Same. So where is the content? The file is very large, so if you print it in the console, it will
take quite some time to print, and you will not really be able to make out anything. The best
way would be to try to detect the string <code>CONTENT</code> and work from there.</p>
</div>
<div id="detecting-getting-the-position-and-locating-strings" class="section level3">
<h3>Detecting, getting the position and locating strings</h3>
<p>When confronted to an atomic vector of strings, you might want to know inside which elements you
can find certain strings. For example, to know which elements of <code>winchester</code> contain the string
<code>CONTENT</code>, use <code>str_detect()</code>:</p>
<pre class="r"><code>winchester %&gt;%
  str_detect(&quot;CONTENT&quot;)</code></pre>
<pre><code>##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [12] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [23] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [34] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE</code></pre>
<p>This returns a boolean atomic vector of the same length as <code>winchester</code>. If the string <code>CONTENT</code> is
nowhere to be found, the result will equal <code>FALSE</code>, if not it will equal <code>TRUE</code>. Here it is easy to
see that the last element contains the string <code>CONTENT</code>. But what if instead of having 43 elements,
the vector had 24192 elements? And hundreds would contain the string <code>CONTENT</code>? It would be easier
to instead have the indices of the vector where one can find the word <code>CONTENT</code>. This is possible
with <code>str_which()</code>:</p>
<pre class="r"><code>winchester %&gt;%
  str_which(&quot;CONTENT&quot;)</code></pre>
<pre><code>## [1] 43</code></pre>
<p>Here, the result is 43, meaning that the 43rd element of <code>winchester</code> contains the string <code>CONTENT</code>
somewhere. If we need more precision, we can use <code>str_locate()</code> and <code>str_locate_all()</code>. To explain
how both these functions work, let’s create a very small example:</p>
<pre class="r"><code>ancient_philosophers &lt;- c(&quot;aristotle&quot;, &quot;plato&quot;, &quot;epictetus&quot;, &quot;seneca the younger&quot;, &quot;epicurus&quot;, &quot;marcus aurelius&quot;)</code></pre>
<p>Now suppose I am interested in philosophers whose name ends in <code>us</code>. Let us use <code>str_locate()</code> first:</p>
<pre class="r"><code>ancient_philosophers %&gt;%
  str_locate(&quot;us&quot;)</code></pre>
<pre><code>##      start end
## [1,]    NA  NA
## [2,]    NA  NA
## [3,]     8   9
## [4,]    NA  NA
## [5,]     7   8
## [6,]     5   6</code></pre>
<p>You can interpret the result as follows: in the rows, the index of the vector where the
string <code>us</code> is found. So the 3rd, 5th and 6th philosopher have <code>us</code> somewhere in their name.
The result also has two columns: <code>start</code> and <code>end</code>. These give the position of the string. So the
string <code>us</code> can be found starting at position 8 of the 3rd element of the vector, and ends at position
9. Same goes for the other philisophers. However, consider Marcus Aurelius. He has two names, both
ending with <code>us</code>. However, <code>str_locate()</code> only shows the position of the <code>us</code> in <code>Marcus</code>.</p>
<p>To get both <code>us</code> strings, you need to use <code>str_locate_all()</code>:</p>
<pre class="r"><code>ancient_philosophers %&gt;%
  str_locate_all(&quot;us&quot;)</code></pre>
<pre><code>## [[1]]
##      start end
## 
## [[2]]
##      start end
## 
## [[3]]
##      start end
## [1,]     8   9
## 
## [[4]]
##      start end
## 
## [[5]]
##      start end
## [1,]     7   8
## 
## [[6]]
##      start end
## [1,]     5   6
## [2,]    14  15</code></pre>
<p>Now we get the position of the two <code>us</code> in Marcus Aurelius. Doing this on the <code>winchester</code> vector
will give use the position of the <code>CONTENT</code> string, but this is not really important right now. What
matters is that you know how <code>str_locate()</code> and <code>str_locate_all()</code> work.</p>
<p>So now that we know what interests us in the 43nd element of <code>winchester</code>, let’s take a closer
look at it:</p>
<pre class="r"><code>winchester[43]</code></pre>
<p>As you can see, it’s a mess:</p>
<pre><code>&lt;TextLine HEIGHT=\&quot;126.0\&quot; WIDTH=\&quot;1731.0\&quot; HPOS=\&quot;17160.0\&quot; VPOS=\&quot;21252.0\&quot;&gt;&lt;String HEIGHT=\&quot;114.0\&quot; WIDTH=\&quot;354.0\&quot; HPOS=\&quot;17160.0\&quot; VPOS=\&quot;21264.0\&quot; CONTENT=\&quot;0tV\&quot; WC=\&quot;0.8095238\&quot;/&gt;&lt;SP WIDTH=\&quot;131.0\&quot; HPOS=\&quot;17514.0\&quot; VPOS=\&quot;21264.0\&quot;/&gt;&lt;String STYLEREFS=\&quot;ID7\&quot; HEIGHT=\&quot;111.0\&quot; WIDTH=\&quot;474.0\&quot; HPOS=\&quot;17646.0\&quot; VPOS=\&quot;21258.0\&quot; CONTENT=\&quot;BATES\&quot; WC=\&quot;1.0\&quot;/&gt;&lt;SP WIDTH=\&quot;140.0\&quot; HPOS=\&quot;18120.0\&quot; VPOS=\&quot;21258.0\&quot;/&gt;&lt;String STYLEREFS=\&quot;ID7\&quot; HEIGHT=\&quot;114.0\&quot; WIDTH=\&quot;630.0\&quot; HPOS=\&quot;18261.0\&quot; VPOS=\&quot;21252.0\&quot; CONTENT=\&quot;President\&quot; WC=\&quot;1.0\&quot;&gt;&lt;ALTERNATIVE&gt;Prcideht&lt;/ALTERNATIVE&gt;&lt;ALTERNATIVE&gt;Pride&lt;/ALTERNATIVE&gt;&lt;/String&gt;&lt;/TextLine&gt;&lt;TextLine HEIGHT=\&quot;153.0\&quot; WIDTH=\&quot;1689.0\&quot; HPOS=\&quot;17145.0\&quot; VPOS=\&quot;21417.0\&quot;&gt;&lt;String STYLEREFS=\&quot;ID7\&quot; HEIGHT=\&quot;105.0\&quot; WIDTH=\&quot;258.0\&quot; HPOS=\&quot;17145.0\&quot; VPOS=\&quot;21439.0\&quot; CONTENT=\&quot;WM\&quot; WC=\&quot;0.82539684\&quot;&gt;&lt;TextLine HEIGHT=\&quot;120.0\&quot; WIDTH=\&quot;2211.0\&quot; HPOS=\&quot;16788.0\&quot; VPOS=\&quot;21870.0\&quot;&gt;&lt;String STYLEREFS=\&quot;ID7\&quot; HEIGHT=\&quot;96.0\&quot; WIDTH=\&quot;102.0\&quot; HPOS=\&quot;16788.0\&quot; VPOS=\&quot;21894.0\&quot; CONTENT=\&quot;It\&quot; WC=\&quot;1.0\&quot;/&gt;&lt;SP WIDTH=\&quot;72.0\&quot; HPOS=\&quot;16890.0\&quot; VPOS=\&quot;21894.0\&quot;/&gt;&lt;String STYLEREFS=\&quot;ID7\&quot; HEIGHT=\&quot;96.0\&quot; WIDTH=\&quot;93.0\&quot; HPOS=\&quot;16962.0\&quot; VPOS=\&quot;21885.0\&quot; CONTENT=\&quot;is\&quot; WC=\&quot;1.0\&quot;/&gt;&lt;SP WIDTH=\&quot;80.0\&quot; HPOS=\&quot;17055.0\&quot; VPOS=\&quot;21885.0\&quot;/&gt;&lt;String STYLEREFS=\&quot;ID7\&quot; HEIGHT=\&quot;102.0\&quot; WIDTH=\&quot;417.0\&quot; HPOS=\&quot;17136.0\&quot; VPOS=\&quot;21879.0\&quot; CONTENT=\&quot;seldom\&quot; WC=\&quot;1.0\&quot;/&gt;&lt;SP WIDTH=\&quot;80.0\&quot; HPOS=\&quot;17553.0\&quot; VPOS=\&quot;21879.0\&quot;/&gt;&lt;String STYLEREFS=\&quot;ID7\&quot; HEIGHT=\&quot;96.0\&quot; WIDTH=\&quot;267.0\&quot; HPOS=\&quot;17634.0\&quot; VPOS=\&quot;21873.0\&quot; CONTENT=\&quot;hard\&quot; WC=\&quot;1.0\&quot;/&gt;&lt;SP WIDTH=\&quot;81.0\&quot; HPOS=\&quot;17901.0\&quot; VPOS=\&quot;21873.0\&quot;/&gt;&lt;String STYLEREFS=\&quot;ID7\&quot; HEIGHT=\&quot;87.0\&quot; WIDTH=\&quot;111.0\&quot; HPOS=\&quot;17982.0\&quot; VPOS=\&quot;21879.0\&quot; CONTENT=\&quot;to\&quot; WC=\&quot;1.0\&quot;/&gt;&lt;SP WIDTH=\&quot;81.0\&quot; HPOS=\&quot;18093.0\&quot; VPOS=\&quot;21879.0\&quot;/&gt;&lt;String STYLEREFS=\&quot;ID7\&quot; HEIGHT=\&quot;96.0\&quot; WIDTH=\&quot;219.0\&quot; HPOS=\&quot;18174.0\&quot; VPOS=\&quot;21870.0\&quot; CONTENT=\&quot;find\&quot; WC=\&quot;1.0\&quot;/&gt;&lt;SP WIDTH=\&quot;77.0\&quot; HPOS=\&quot;18393.0\&quot; VPOS=\&quot;21870.0\&quot;/&gt;&lt;String STYLEREFS=\&quot;ID7\&quot; HEIGHT=\&quot;69.0\&quot; WIDTH=\&quot;66.0\&quot; HPOS=\&quot;18471.0\&quot; VPOS=\&quot;21894.0\&quot; CONTENT=\&quot;a\&quot; WC=\&quot;1.0\&quot;/&gt;&lt;SP WIDTH=\&quot;77.0\&quot; HPOS=\&quot;18537.0\&quot; VPOS=\&quot;21894.0\&quot;/&gt;&lt;String STYLEREFS=\&quot;ID7\&quot; HEIGHT=\&quot;78.0\&quot; WIDTH=\&quot;384.0\&quot; HPOS=\&quot;18615.0\&quot; VPOS=\&quot;21888.0\&quot; CONTENT=\&quot;succes\&quot; WC=\&quot;0.82539684\&quot;&gt;&lt;ALTERNATIVE&gt;success&lt;/ALTERNATIVE&gt;&lt;/String&gt;&lt;/TextLine&gt;&lt;TextLine HEIGHT=\&quot;126.0\&quot; WIDTH=\&quot;2316.0\&quot; HPOS=\&quot;16662.0\&quot; VPOS=\&quot;22008.0\&quot;&gt;&lt;String STYLEREFS=\&quot;ID7\&quot; HEIGHT=\&quot;75.0\&quot; WIDTH=\&quot;183.0\&quot; HPOS=\&quot;16662.0\&quot; VPOS=\&quot;22059.0\&quot; CONTENT=\&quot;sor\&quot; WC=\&quot;1.0\&quot;&gt;&lt;ALTERNATIVE&gt;soar&lt;/ALTERNATIVE&gt;&lt;/String&gt;&lt;SP WIDTH=\&quot;72.0\&quot; HPOS=\&quot;16845.0\&quot; VPOS=\&quot;22059.0\&quot;/&gt;&lt;String STYLEREFS=\&quot;ID7\&quot; HEIGHT=\&quot;90.0\&quot; WIDTH=\&quot;168.0\&quot; HPOS=\&quot;16917.0\&quot; VPOS=\&quot;22035.0\&quot; CONTENT=\&quot;for\&quot; WC=\&quot;1.0\&quot;/&gt;&lt;SP WIDTH=\&quot;72.0\&quot; HPOS=\&quot;17085.0\&quot; VPOS=\&quot;22035.0\&quot;/&gt;&lt;String STYLEREFS=\&quot;ID7\&quot; HEIGHT=\&quot;69.0\&quot; WIDTH=\&quot;267.0\&quot; HPOS=\&quot;17157.0\&quot; VPOS=\&quot;22050.0\&quot; CONTENT=\&quot;even\&quot; WC=\&quot;1.0\&quot;&gt;&lt;ALTERNATIVE&gt;cen&lt;/ALTERNATIVE&gt;&lt;ALTERNATIVE&gt;cent&lt;/ALTERNATIVE&gt;&lt;/String&gt;&lt;SP WIDTH=\&quot;77.0\&quot; HPOS=\&quot;17434.0\&quot; VPOS=\&quot;22050.0\&quot;/&gt;&lt;String STYLEREFS=\&quot;ID7\&quot; HEIGHT=\&quot;66.0\&quot; WIDTH=\&quot;63.0\&quot; HPOS=\&quot;17502.0\&quot; VPOS=\&quot;22044.0\&quot;</code></pre>
<p>The file was imported without any newlines. So we need to insert them ourselves, by splitting the
string in a clever way.</p>
</div>
<div id="splitting-strings" class="section level3">
<h3>Splitting strings</h3>
<p>There are two functions included in <code>{stringr}</code> to split strings, <code>str_split()</code> and <code>str_split_fixed()</code>.
Let’s go back to our ancient philosophers. Two of them, Seneca the Younger and Marcus Aurelius have
something else in common than both being Roman Stoic philosophers. Their names are composed of several
words. If we want to split their names at the space character, we can use <code>str_split()</code> like this:</p>
<pre class="r"><code>ancient_philosophers %&gt;%
  str_split(&quot; &quot;)</code></pre>
<pre><code>## [[1]]
## [1] &quot;aristotle&quot;
## 
## [[2]]
## [1] &quot;plato&quot;
## 
## [[3]]
## [1] &quot;epictetus&quot;
## 
## [[4]]
## [1] &quot;seneca&quot;  &quot;the&quot;     &quot;younger&quot;
## 
## [[5]]
## [1] &quot;epicurus&quot;
## 
## [[6]]
## [1] &quot;marcus&quot;   &quot;aurelius&quot;</code></pre>
<p><code>str_split()</code> also has a <code>simplify = TRUE</code> option:</p>
<pre class="r"><code>ancient_philosophers %&gt;%
  str_split(&quot; &quot;, simplify = TRUE)</code></pre>
<pre><code>##      [,1]        [,2]       [,3]     
## [1,] &quot;aristotle&quot; &quot;&quot;         &quot;&quot;       
## [2,] &quot;plato&quot;     &quot;&quot;         &quot;&quot;       
## [3,] &quot;epictetus&quot; &quot;&quot;         &quot;&quot;       
## [4,] &quot;seneca&quot;    &quot;the&quot;      &quot;younger&quot;
## [5,] &quot;epicurus&quot;  &quot;&quot;         &quot;&quot;       
## [6,] &quot;marcus&quot;    &quot;aurelius&quot; &quot;&quot;</code></pre>
<p>This time, the returned object is a matrix.</p>
<p>What about <code>str_split_fixed()</code>? The difference is that here you can specify the number of pieces
to return. For example, you could consider the name “Aurelius” to be the middle name of Marcus Aurelius,
and the “the younger” to be the middle name of Seneca the younger. This means that you would want
to split the name only at the first space character, and not at all of them. This is easily achieved
with <code>str_split_fixed()</code>:</p>
<pre class="r"><code>ancient_philosophers %&gt;%
  str_split_fixed(&quot; &quot;, 2)</code></pre>
<pre><code>##      [,1]        [,2]         
## [1,] &quot;aristotle&quot; &quot;&quot;           
## [2,] &quot;plato&quot;     &quot;&quot;           
## [3,] &quot;epictetus&quot; &quot;&quot;           
## [4,] &quot;seneca&quot;    &quot;the younger&quot;
## [5,] &quot;epicurus&quot;  &quot;&quot;           
## [6,] &quot;marcus&quot;    &quot;aurelius&quot;</code></pre>
<p>This gives the expected result.</p>
<p>So how does this help in our case? Well, if you look at how the ALTO file looks like, at the beginning
of this section, you will notice that every line ends with the “&gt;” character. So let’s split at
that character!</p>
<pre class="r"><code>winchester_text &lt;- winchester[43] %&gt;%
  str_split(&quot;&gt;&quot;)</code></pre>
<p>Let’s take a closer look at <code>winchester_text</code>:</p>
<pre class="r"><code>str(winchester_text)</code></pre>
<pre><code>## List of 1
##  $ : chr [1:19706] &quot;&lt;/processingStepSettings&quot; &quot;&lt;processingSoftware&quot; &quot;&lt;softwareCreator&quot; &quot;iArchives&lt;/softwareCreator&quot; ...</code></pre>
<p>So this is a list of length one, and the first, and only, element of that list is an atomic vector
with 19706 elements. Since this is a list of only one element, we can simplify it by saving the
atomic vector in a variable:</p>
<pre class="r"><code>winchester_text &lt;- winchester_text[[1]]</code></pre>
<p>Let’s now look at some lines:</p>
<pre class="r"><code>winchester_text[1232:1245]</code></pre>
<pre><code>##  [1] &quot;&lt;SP WIDTH=\&quot;66.0\&quot; HPOS=\&quot;5763.0\&quot; VPOS=\&quot;9696.0\&quot;/&quot;                                                                         
##  [2] &quot;&lt;String STYLEREFS=\&quot;ID7\&quot; HEIGHT=\&quot;108.0\&quot; WIDTH=\&quot;612.0\&quot; HPOS=\&quot;5829.0\&quot; VPOS=\&quot;9693.0\&quot; CONTENT=\&quot;Louisville\&quot; WC=\&quot;1.0\&quot;&quot;
##  [3] &quot;&lt;ALTERNATIVE&quot;                                                                                                                
##  [4] &quot;Loniile&lt;/ALTERNATIVE&quot;                                                                                                        
##  [5] &quot;&lt;ALTERNATIVE&quot;                                                                                                                
##  [6] &quot;Lenities&lt;/ALTERNATIVE&quot;                                                                                                       
##  [7] &quot;&lt;/String&quot;                                                                                                                    
##  [8] &quot;&lt;/TextLine&quot;                                                                                                                  
##  [9] &quot;&lt;TextLine HEIGHT=\&quot;150.0\&quot; WIDTH=\&quot;2520.0\&quot; HPOS=\&quot;4032.0\&quot; VPOS=\&quot;9849.0\&quot;&quot;                                                 
## [10] &quot;&lt;String STYLEREFS=\&quot;ID7\&quot; HEIGHT=\&quot;108.0\&quot; WIDTH=\&quot;510.0\&quot; HPOS=\&quot;4032.0\&quot; VPOS=\&quot;9861.0\&quot; CONTENT=\&quot;Tobacco\&quot; WC=\&quot;1.0\&quot;/&quot;  
## [11] &quot;&lt;SP WIDTH=\&quot;113.0\&quot; HPOS=\&quot;4542.0\&quot; VPOS=\&quot;9861.0\&quot;/&quot;                                                                        
## [12] &quot;&lt;String STYLEREFS=\&quot;ID7\&quot; HEIGHT=\&quot;105.0\&quot; WIDTH=\&quot;696.0\&quot; HPOS=\&quot;4656.0\&quot; VPOS=\&quot;9861.0\&quot; CONTENT=\&quot;Warehouse\&quot; WC=\&quot;1.0\&quot;&quot; 
## [13] &quot;&lt;ALTERNATIVE&quot;                                                                                                                
## [14] &quot;WHrchons&lt;/ALTERNATIVE&quot;</code></pre>
<p>This now looks easier to handle. We can narrow it down to the lines that only contain the string
we are interested in, “CONTENT”. First, let’s get the indices:</p>
<pre class="r"><code>content_winchester_index &lt;- winchester_text %&gt;%
  str_which(&quot;CONTENT&quot;)</code></pre>
<p>How many lines contain the string “CONTENT”?</p>
<pre class="r"><code>length(content_winchester_index)</code></pre>
<pre><code>## [1] 4462</code></pre>
<p>As you can see, this reduces the amount of data we have to work with. Let us save this is a new
variable:</p>
<pre class="r"><code>content_winchester &lt;- winchester_text[content_winchester_index]</code></pre>
</div>
<div id="matching-strings" class="section level3">
<h3>Matching strings</h3>
<p>Matching strings is useful, but only in combination with regular expressions. As stated at the
beginning of this section, we are going to learn about regular expressions in Chapter 10, but in
order to make this section useful, we are going to learn the easiest, but perhaps the most useful
regular expression: <code>.*</code>.</p>
<p>Let’s go back to our ancient philosophers, and use <code>str_match()</code> and see what happens. Let’s match
the “us” string:</p>
<pre class="r"><code>ancient_philosophers %&gt;%
  str_match(&quot;us&quot;)</code></pre>
<pre><code>##      [,1]
## [1,] NA  
## [2,] NA  
## [3,] &quot;us&quot;
## [4,] NA  
## [5,] &quot;us&quot;
## [6,] &quot;us&quot;</code></pre>
<p>Not very useful, but what about the regular expression <code>.*</code>? How could it help?</p>
<pre class="r"><code>ancient_philosophers %&gt;%
  str_match(&quot;.*us&quot;)</code></pre>
<pre><code>##      [,1]             
## [1,] NA               
## [2,] NA               
## [3,] &quot;epictetus&quot;      
## [4,] NA               
## [5,] &quot;epicurus&quot;       
## [6,] &quot;marcus aurelius&quot;</code></pre>
<p>That’s already very interesting! So how does <code>.*</code> work? To understand, let’s first start by using
<code>.</code> alone:</p>
<pre class="r"><code>ancient_philosophers %&gt;%
  str_match(&quot;.us&quot;)</code></pre>
<pre><code>##      [,1] 
## [1,] NA   
## [2,] NA   
## [3,] &quot;tus&quot;
## [4,] NA   
## [5,] &quot;rus&quot;
## [6,] &quot;cus&quot;</code></pre>
<p>This also matched whatever symbol comes just before the “u” from “us”. What if we use two <code>.</code> instead?</p>
<pre class="r"><code>ancient_philosophers %&gt;%
  str_match(&quot;..us&quot;)</code></pre>
<pre><code>##      [,1]  
## [1,] NA    
## [2,] NA    
## [3,] &quot;etus&quot;
## [4,] NA    
## [5,] &quot;urus&quot;
## [6,] &quot;rcus&quot;</code></pre>
<p>This time, we get the two symbols that immediately precede “us”. Instead of continuing like this
we now use the <code>*</code>, which matches zero or more of <code>.</code>. So by combining <code>*</code> and <code>.</code>, we can match
any symbol repeatedly, until there is nothing more to match. Note that there is also <code>+</code>, which works
similarly to <code>*</code>, but it matches one or more symbols.</p>
<p>There is also a <code>str_match_all()</code>:</p>
<pre class="r"><code>ancient_philosophers %&gt;%
  str_match_all(&quot;.*us&quot;)</code></pre>
<pre><code>## [[1]]
##      [,1]
## 
## [[2]]
##      [,1]
## 
## [[3]]
##      [,1]       
## [1,] &quot;epictetus&quot;
## 
## [[4]]
##      [,1]
## 
## [[5]]
##      [,1]      
## [1,] &quot;epicurus&quot;
## 
## [[6]]
##      [,1]             
## [1,] &quot;marcus aurelius&quot;</code></pre>
<p>In this particular case it does not change the end result, but keep it in mind for cases like this one:</p>
<pre class="r"><code>c(&quot;haha&quot;, &quot;huhu&quot;) %&gt;%
  str_match(&quot;ha&quot;)</code></pre>
<pre><code>##      [,1]
## [1,] &quot;ha&quot;
## [2,] NA</code></pre>
<p>and:</p>
<pre class="r"><code>c(&quot;haha&quot;, &quot;huhu&quot;) %&gt;%
  str_match_all(&quot;ha&quot;)</code></pre>
<pre><code>## [[1]]
##      [,1]
## [1,] &quot;ha&quot;
## [2,] &quot;ha&quot;
## 
## [[2]]
##      [,1]</code></pre>
<p>What if we want to match names containing the letter “t”? Easy:</p>
<pre class="r"><code>ancient_philosophers %&gt;%
  str_match(&quot;.*t.*&quot;)</code></pre>
<pre><code>##      [,1]                
## [1,] &quot;aristotle&quot;         
## [2,] &quot;plato&quot;             
## [3,] &quot;epictetus&quot;         
## [4,] &quot;seneca the younger&quot;
## [5,] NA                  
## [6,] NA</code></pre>
<p>So how does this help us with our historical newspaper? Let’s try to get the strings that come
after “CONTENT”:</p>
<pre class="r"><code>winchester_content &lt;- winchester_text %&gt;%
  str_match(&quot;CONTENT.*&quot;)</code></pre>
<p>Let’s use our faithful <code>str()</code> function to take a look:</p>
<pre class="r"><code>winchester_content %&gt;%
  str</code></pre>
<pre><code>##  chr [1:19706, 1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ...</code></pre>
<p>Hum, there’s a lot of <code>NA</code> values! This is because a lot of the lines from the file did not have the
string “CONTENT”, so there is no match possible. Let’s us remove all these <code>NA</code>s. Because the
result is a matrix, we cannot use the <code>filter()</code> function from <code>{dplyr}</code>. So we need to convert it
to a tibble first:</p>
<pre class="r"><code>winchester_content &lt;- winchester_content %&gt;%
  as.tibble() %&gt;%
  filter(!is.na(V1))</code></pre>
<pre><code>## Warning: `as.tibble()` is deprecated, use `as_tibble()` (but mind the new semantics).
## This warning is displayed once per session.</code></pre>
<p>Because matrix columns do not have names, when a matrix gets converted into a tibble, the firt column
gets automatically called <code>V1</code>. This is why I filter on this column. Let’s take a look at the data:</p>
<pre class="r"><code>head(winchester_content)</code></pre>
<pre><code>## # A tibble: 6 x 1
##   V1                                  
##   &lt;chr&gt;                               
## 1 &quot;CONTENT=\&quot;J\&quot; WC=\&quot;0.8095238\&quot;/&quot;   
## 2 &quot;CONTENT=\&quot;a\&quot; WC=\&quot;0.8095238\&quot;/&quot;   
## 3 &quot;CONTENT=\&quot;Ira\&quot; WC=\&quot;0.95238096\&quot;/&quot;
## 4 &quot;CONTENT=\&quot;mj\&quot; WC=\&quot;0.8095238\&quot;/&quot;  
## 5 &quot;CONTENT=\&quot;iI\&quot; WC=\&quot;0.8095238\&quot;/&quot;  
## 6 &quot;CONTENT=\&quot;tE1r\&quot; WC=\&quot;0.8095238\&quot;/&quot;</code></pre>
</div>
<div id="searching-and-replacing-strings" class="section level3">
<h3>Searching and replacing strings</h3>
<p>We are getting close to the final result. We still need to do some cleaning however. Since our data
is inside a nice tibble, we might as well stick with it. So let’s first rename the column and
change all the strings to lowercase:</p>
<pre class="r"><code>winchester_content &lt;- winchester_content %&gt;% 
  mutate(content = tolower(V1)) %&gt;% 
  select(-V1)</code></pre>
<p>Let’s take a look at the result:</p>
<pre class="r"><code>head(winchester_content)</code></pre>
<pre><code>## # A tibble: 6 x 1
##   content                             
##   &lt;chr&gt;                               
## 1 &quot;content=\&quot;j\&quot; wc=\&quot;0.8095238\&quot;/&quot;   
## 2 &quot;content=\&quot;a\&quot; wc=\&quot;0.8095238\&quot;/&quot;   
## 3 &quot;content=\&quot;ira\&quot; wc=\&quot;0.95238096\&quot;/&quot;
## 4 &quot;content=\&quot;mj\&quot; wc=\&quot;0.8095238\&quot;/&quot;  
## 5 &quot;content=\&quot;ii\&quot; wc=\&quot;0.8095238\&quot;/&quot;  
## 6 &quot;content=\&quot;te1r\&quot; wc=\&quot;0.8095238\&quot;/&quot;</code></pre>
<p>The second part of the string, “wc=….” is not really interesting. Let’s search and replace this
with an empty string, using <code>str_replace()</code>:</p>
<pre class="r"><code>winchester_content &lt;- winchester_content %&gt;% 
  mutate(content = str_replace(content, &quot;wc.*&quot;, &quot;&quot;))

head(winchester_content)</code></pre>
<pre><code>## # A tibble: 6 x 1
##   content            
##   &lt;chr&gt;              
## 1 &quot;content=\&quot;j\&quot; &quot;   
## 2 &quot;content=\&quot;a\&quot; &quot;   
## 3 &quot;content=\&quot;ira\&quot; &quot; 
## 4 &quot;content=\&quot;mj\&quot; &quot;  
## 5 &quot;content=\&quot;ii\&quot; &quot;  
## 6 &quot;content=\&quot;te1r\&quot; &quot;</code></pre>
<p>We need to use the regular expression from before to replace “wc” and every character that follows.
The same can be use to remove “content=”:</p>
<pre class="r"><code>winchester_content &lt;- winchester_content %&gt;% 
  mutate(content = str_replace(content, &quot;content=&quot;, &quot;&quot;))

head(winchester_content)</code></pre>
<pre><code>## # A tibble: 6 x 1
##   content    
##   &lt;chr&gt;      
## 1 &quot;\&quot;j\&quot; &quot;   
## 2 &quot;\&quot;a\&quot; &quot;   
## 3 &quot;\&quot;ira\&quot; &quot; 
## 4 &quot;\&quot;mj\&quot; &quot;  
## 5 &quot;\&quot;ii\&quot; &quot;  
## 6 &quot;\&quot;te1r\&quot; &quot;</code></pre>
<p>We are almost done, but some cleaning is still necessary:</p>
</div>
<div id="exctracting-or-removing-strings" class="section level3">
<h3>Exctracting or removing strings</h3>
<p>Now, because I now the ALTO spec, I know how to find words that are split between two sentences:</p>
<pre class="r"><code>winchester_content %&gt;% 
  filter(str_detect(content, &quot;hyppart&quot;))</code></pre>
<pre><code>## # A tibble: 64 x 1
##    content                                                               
##    &lt;chr&gt;                                                                 
##  1 &quot;\&quot;aver\&quot; subs_type=\&quot;hyppart1\&quot; subs_content=\&quot;average\&quot; &quot;           
##  2 &quot;\&quot;age\&quot; subs_type=\&quot;hyppart2\&quot; subs_content=\&quot;average\&quot; &quot;            
##  3 &quot;\&quot;considera\&quot; subs_type=\&quot;hyppart1\&quot; subs_content=\&quot;consideration\&quot; &quot;
##  4 &quot;\&quot;tion\&quot; subs_type=\&quot;hyppart2\&quot; subs_content=\&quot;consideration\&quot; &quot;     
##  5 &quot;\&quot;re\&quot; subs_type=\&quot;hyppart1\&quot; subs_content=\&quot;resigned\&quot; &quot;            
##  6 &quot;\&quot;signed\&quot; subs_type=\&quot;hyppart2\&quot; subs_content=\&quot;resigned\&quot; &quot;        
##  7 &quot;\&quot;install\&quot; subs_type=\&quot;hyppart1\&quot; subs_content=\&quot;installed\&quot; &quot;      
##  8 &quot;\&quot;ed\&quot; subs_type=\&quot;hyppart2\&quot; subs_content=\&quot;installed\&quot; &quot;           
##  9 &quot;\&quot;be\&quot; subs_type=\&quot;hyppart1\&quot; subs_content=\&quot;before\&quot; &quot;              
## 10 &quot;\&quot;fore\&quot; subs_type=\&quot;hyppart2\&quot; subs_content=\&quot;before\&quot; &quot;            
## # … with 54 more rows</code></pre>
<p>For instance, the word “average” was split over two lines, the first part of the word, “aver” on the
first line, and the second part of the word, “age”, on the second line. We want to keep what comes
after “subs_content”. Let’s extract the word “average” using <code>str_extract()</code>. However, because only
some words were split between two lines, we first need to detect where the string “hyppart1” is
located, and only then can we extract what comes after “subs_content”. Thus, we need to combine
<code>str_detect()</code> to first detect the string, and then <code>str_extract()</code> to extract what comes after
“subs_content”:</p>
<pre class="r"><code>winchester_content &lt;- winchester_content %&gt;% 
  mutate(content = if_else(str_detect(content, &quot;hyppart1&quot;), 
                           str_extract_all(content, &quot;content=.*&quot;, simplify = TRUE), 
                           content))</code></pre>
<p>Let’s take a look at the result:</p>
<pre class="r"><code>winchester_content %&gt;% 
  filter(str_detect(content, &quot;content&quot;))</code></pre>
<pre><code>## # A tibble: 64 x 1
##    content                                                          
##    &lt;chr&gt;                                                            
##  1 &quot;content=\&quot;average\&quot; &quot;                                           
##  2 &quot;\&quot;age\&quot; subs_type=\&quot;hyppart2\&quot; subs_content=\&quot;average\&quot; &quot;       
##  3 &quot;content=\&quot;consideration\&quot; &quot;                                     
##  4 &quot;\&quot;tion\&quot; subs_type=\&quot;hyppart2\&quot; subs_content=\&quot;consideration\&quot; &quot;
##  5 &quot;content=\&quot;resigned\&quot; &quot;                                          
##  6 &quot;\&quot;signed\&quot; subs_type=\&quot;hyppart2\&quot; subs_content=\&quot;resigned\&quot; &quot;   
##  7 &quot;content=\&quot;installed\&quot; &quot;                                         
##  8 &quot;\&quot;ed\&quot; subs_type=\&quot;hyppart2\&quot; subs_content=\&quot;installed\&quot; &quot;      
##  9 &quot;content=\&quot;before\&quot; &quot;                                            
## 10 &quot;\&quot;fore\&quot; subs_type=\&quot;hyppart2\&quot; subs_content=\&quot;before\&quot; &quot;       
## # … with 54 more rows</code></pre>
<p>We still need to get rid of the string “content=” and then of all the strings that contain “hyppart2”,
which are not needed now:</p>
<pre class="r"><code>winchester_content &lt;- winchester_content %&gt;% 
  mutate(content = str_replace(content, &quot;content=&quot;, &quot;&quot;)) %&gt;% 
  mutate(content = if_else(str_detect(content, &quot;hyppart2&quot;), NA_character_, content))

head(winchester_content)</code></pre>
<pre><code>## # A tibble: 6 x 1
##   content    
##   &lt;chr&gt;      
## 1 &quot;\&quot;j\&quot; &quot;   
## 2 &quot;\&quot;a\&quot; &quot;   
## 3 &quot;\&quot;ira\&quot; &quot; 
## 4 &quot;\&quot;mj\&quot; &quot;  
## 5 &quot;\&quot;ii\&quot; &quot;  
## 6 &quot;\&quot;te1r\&quot; &quot;</code></pre>
<p>Almost done! We only need to remove the <code>"</code> characters:</p>
<pre class="r"><code>winchester_content &lt;- winchester_content %&gt;% 
  mutate(content = str_replace_all(content, &quot;\&quot;&quot;, &quot;&quot;)) 

head(winchester_content)</code></pre>
<pre><code>## # A tibble: 6 x 1
##   content
##   &lt;chr&gt;  
## 1 &quot;j &quot;   
## 2 &quot;a &quot;   
## 3 &quot;ira &quot; 
## 4 &quot;mj &quot;  
## 5 &quot;ii &quot;  
## 6 &quot;te1r &quot;</code></pre>
<p>Let’s remove space characters with <code>str_trim()</code>:</p>
<pre class="r"><code>winchester_content &lt;- winchester_content %&gt;% 
  mutate(content = str_trim(content)) 

head(winchester_content)</code></pre>
<pre><code>## # A tibble: 6 x 1
##   content
##   &lt;chr&gt;  
## 1 j      
## 2 a      
## 3 ira    
## 4 mj     
## 5 ii     
## 6 te1r</code></pre>
<p>To finish off this section, let’s remove stop words (words that do not add any meaning to a sentence,
such as “as”, “and”…) and words that are composed of less than 3 characters. You can find a dataset
with stopwords inside the <code>{stopwords}</code> package:</p>
<pre class="r"><code>library(stopwords)

data(data_stopwords_stopwordsiso)

eng_stopwords &lt;- tibble(&quot;content&quot; = data_stopwords_stopwordsiso$en)

winchester_content &lt;- winchester_content %&gt;% 
  anti_join(eng_stopwords) %&gt;% 
  filter(nchar(content) &gt; 3)</code></pre>
<pre><code>## Joining, by = &quot;content&quot;</code></pre>
<pre class="r"><code>head(winchester_content)</code></pre>
<pre><code>## # A tibble: 6 x 1
##   content   
##   &lt;chr&gt;     
## 1 te1r      
## 2 jilas     
## 3 edition   
## 4 winchester
## 5 news      
## 6 injuries</code></pre>
<p>That’s it for this section! You now know how to work with strings, but in Chapter 10 we are going
one step further by learning about regular expressions, which offer much more power.</p>
<p>Hope you enjoyed! If you found this blog post useful, you might want to follow
me on <a href="https://www.twitter.com/brodriguesco">twitter</a> for blog post updates and
<a href="https://www.buymeacoffee.com/brodriguesco">buy me an espresso</a> or <a href="https://www.paypal.me/brodriguesco">paypal.me</a>.</p>
<style>.bmc-button img{width: 27px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-flex !important;color:#ffffff !important;background-color:#272b30 !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 1px 9px !important;font-size: 22px !important;letter-spacing:0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:'Cookie', cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#82518c !important;}</style>
<p><link href="https://fonts.googleapis.com/css?family=Cookie" rel="stylesheet"><a class="bmc-button" target="_blank" href="https://www.buymeacoffee.com/brodriguesco"><img src="https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg" alt="Buy me an Espresso"><span style="margin-left:5px">Buy me an Espresso</span></a></p>
</div>
</div>

			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/blog/2023-10-20-nix_for_r_part7/">Reproducible data science with Nix, part 7 -- Building a Quarto book using Nix on Github Actions</a></li>
				
				<li><a href="/blog/2023-10-05-repro_overview/">An overview of what&#39;s out there for reproducibility with R</a></li>
				
				<li><a href="/blog/2023-09-29-voyager/">ZSA Voyager review</a></li>
				
				<li><a href="/blog/2023-09-20-nix_for_r_part6/">Reproducible data science with Nix, part 6 -- CI/CD has never been easier</a></li>
				
				<li><a href="/blog/2023-09-15-nix_for_r_part5/">Reproducible data science with Nix, part 5 -- Reproducible literate programming with Nix and Quarto</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
  <div class="row">
    <div class="col-lg-12">
      <p>2023, content by Bruno Rodrigues, unless otherwise stated, every content of this blog is licensed under the <a href="http://www.wtfpl.net/txt/copying/" rel="nofollow">WTFPL</a>.</p>
      <p>The theme this blog uses is a slight variation of the <a href="https://github.com/colorchestra/smol" rel="nofollow">Smol</a> theme.</p>
      <p><a class="nav-link" href="/index.html">Back to main page.</a></p>
    </div>
  </div>
</footer>

</body>
</html>
