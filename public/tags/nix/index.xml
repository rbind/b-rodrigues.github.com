<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nix on Econometrics and Free Software</title>
    <link>https://www.brodrigues.co/tags/nix/</link>
    <description>Recent content in Nix on Econometrics and Free Software</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 02 Feb 2024 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://www.brodrigues.co/tags/nix/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Reproducible data science with Nix, part 9 -- rix is looking for testers!</title>
      <link>https://www.brodrigues.co/blog/2024-02-02-nix_for_r_part_9/</link>
      <pubDate>Fri, 02 Feb 2024 00:00:00 +0000</pubDate>
      
      <guid>https://www.brodrigues.co/blog/2024-02-02-nix_for_r_part_9/</guid>
      <description>&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;p&gt;&lt;img src=&#34;https://www.brodrigues.co/img/kick_rix.png&#34;&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;After 5 months of work, &lt;a href=&#34;https://github.com/philipp-baumann&#34;&gt;Philipp Baumann&lt;/a&gt;
and myself are happy to announce that our package, &lt;code&gt;{rix}&lt;/code&gt; is getting quite
close to being in a state we consider “done” (well, at least, for a first
release). We plan on submit it first to
&lt;a href=&#34;https://ropensci.org/software-review/&#34;&gt;rOpenSci&lt;/a&gt; for review, and later to CRAN.
But in the meantime, if you could test the package, we’d be grateful! We are
especially interested to see if you find the documentation clear, and if you are
able to run the features that require an installation of Nix, the &lt;code&gt;nix_build()&lt;/code&gt;
and &lt;code&gt;with_nix()&lt;/code&gt; functions. And I would truly recommend you read this blog post
to the end, because I guarantee you’ll have your mind blown! If that’s not the
case, send an insult my way on social media.&lt;/p&gt;
&lt;div id=&#34;what-is-rix&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;What is rix?&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;{rix}&lt;/code&gt; is an R package that leverages Nix, a powerful package manager focusing
on reproducible builds. With Nix, it is possible to create project-specific
environments that contain a project-specific version of R and R packages (as
well as other tools or languages, if needed). You can use &lt;code&gt;{rix}&lt;/code&gt; and Nix to
replace renv and Docker with one single tool. Nix is an incredibly useful piece
of software for ensuring reproducibility of projects, in research or otherwise,
or for running web applications like Shiny apps or plumber APIs in a controlled
environment. The advantage of using Nix over Docker is that the environments
that you define using Nix are not isolated from the rest of your machine: you
can still access files and other tools installed on your computer.&lt;/p&gt;
&lt;p&gt;For example, here is how you could use &lt;code&gt;{rix}&lt;/code&gt; to generate a file called
&lt;code&gt;default.nix&lt;/code&gt;, which can then be used by Nix to actually build that environment
for you:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(rix)

path_default_nix &amp;lt;- tempdir()

rix(r_ver = &amp;quot;latest&amp;quot;,
    r_pkgs = c(&amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;),
    system_pkgs = NULL,
    git_pkgs = NULL,
    ide = &amp;quot;code&amp;quot;,
    shell_hook = NULL,
    project_path = path_default_nix,
    overwrite = TRUE,
    print = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # This file was generated by the {rix} R package v0.5.1.9000 on 2024-02-02
## # with following call:
## # &amp;gt;rix(r_ver = &amp;quot;5ad9903c16126a7d949101687af0aa589b1d7d3d&amp;quot;,
## #  &amp;gt; r_pkgs = c(&amp;quot;dplyr&amp;quot;,
## #  &amp;gt; &amp;quot;ggplot2&amp;quot;),
## #  &amp;gt; system_pkgs = NULL,
## #  &amp;gt; git_pkgs = NULL,
## #  &amp;gt; ide = &amp;quot;code&amp;quot;,
## #  &amp;gt; project_path = path_default_nix,
## #  &amp;gt; overwrite = TRUE,
## #  &amp;gt; print = TRUE,
## #  &amp;gt; shell_hook = NULL)
## # It uses nixpkgs&amp;#39; revision 5ad9903c16126a7d949101687af0aa589b1d7d3d for reproducibility purposes
## # which will install R version latest
## # Report any issues to https://github.com/b-rodrigues/rix
## let
##  pkgs = import (fetchTarball &amp;quot;https://github.com/NixOS/nixpkgs/archive/5ad9903c16126a7d949101687af0aa589b1d7d3d.tar.gz&amp;quot;) {};
##  rpkgs = builtins.attrValues {
##   inherit (pkgs.rPackages) dplyr ggplot2 languageserver;
## };
##    system_packages = builtins.attrValues {
##   inherit (pkgs) R glibcLocales nix ;
## };
##   in
##   pkgs.mkShell {
##     LOCALE_ARCHIVE = if pkgs.system == &amp;quot;x86_64-linux&amp;quot; then  &amp;quot;${pkgs.glibcLocales}/lib/locale/locale-archive&amp;quot; else &amp;quot;&amp;quot;;
##     LANG = &amp;quot;en_US.UTF-8&amp;quot;;
##     LC_ALL = &amp;quot;en_US.UTF-8&amp;quot;;
##     LC_TIME = &amp;quot;en_US.UTF-8&amp;quot;;
##     LC_MONETARY = &amp;quot;en_US.UTF-8&amp;quot;;
##     LC_PAPER = &amp;quot;en_US.UTF-8&amp;quot;;
##     LC_MEASUREMENT = &amp;quot;en_US.UTF-8&amp;quot;;
## 
##     buildInputs = [  rpkgs  system_packages  ];
##       
##   }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You don’t need to have Nix installed to use &lt;code&gt;{rix}&lt;/code&gt; and generate this
expression! This is especially useful if you want to generate an expression that
should then be used in a CI/CD environment for example.&lt;/p&gt;
&lt;p&gt;But if you do have Nix installed, then you can use two great functions that
Philipp implemented, which we are really excited to tell you about!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;nix_build-and-with_nix&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;nix_build() and with_nix()&lt;/h2&gt;
&lt;p&gt;When you have a &lt;code&gt;default.nix&lt;/code&gt; file that was generated by &lt;code&gt;rix::rix()&lt;/code&gt;, and if
you have Nix installed on your system, you can build the corresponding
environment using the command line tool &lt;code&gt;nix-build&lt;/code&gt;. But you can also build that
environment straight from an R session, by using
&lt;a href=&#34;https://b-rodrigues.github.io/rix/reference/nix_build.html&#34;&gt;&lt;code&gt;rix::nix_build()&lt;/code&gt;&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;But the reason
&lt;a href=&#34;https://b-rodrigues.github.io/rix/reference/nix_build.html&#34;&gt;&lt;code&gt;nix_build()&lt;/code&gt;&lt;/a&gt; is
really useful, is because it gets called by
&lt;a href=&#34;https://b-rodrigues.github.io/rix/reference/with_nix.html&#34;&gt;&lt;code&gt;with_nix()&lt;/code&gt;&lt;/a&gt;.
&lt;a href=&#34;https://b-rodrigues.github.io/rix/reference/with_nix.html&#34;&gt;&lt;code&gt;with_nix()&lt;/code&gt;&lt;/a&gt; is a
very interesting function, because it allows you to evaluate a single function
within a so-called subshell. That subshell can have a whole other version of R
and R packages than your main session, and you can use it to execute an
arbitrary function (or a whole, complex expression), and then get the result
back into your main session. You could use older versions of packages to get a
result that might not be possible to get in a current version. Consider the
following example: on a recent version of &lt;code&gt;{stringr}&lt;/code&gt;,
&lt;code&gt;stringr::str_subset(c(&#34;&#34;, &#34;a&#34;), &#34;&#34;)&lt;/code&gt; results in an error, but older versions
would return &lt;code&gt;&#34;a&#34;&lt;/code&gt;. Returning an error is actually what this should do, but hey,
if you have code that relies on that old behaviour you can now execute that old
code within a subshell that contains that older version of &lt;code&gt;{stringr}&lt;/code&gt;. Start by
creating a folder to contain everything needed for your subshell:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;path_env_stringr &amp;lt;- file.path(&amp;quot;.&amp;quot;, &amp;quot;_env_stringr_1.4.1&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, it is advised to use
&lt;a href=&#34;https://b-rodrigues.github.io/rix/reference/rix_init.html&#34;&gt;&lt;code&gt;rix::rix_init()&lt;/code&gt;&lt;/a&gt;
to generate an &lt;code&gt;.Rprofile&lt;/code&gt; for that subshell, which sets a number of environment
variables. This way, when the R session in that subshell starts, we don’t have
any interference between that subshell and the main R session, as the R packages
that must be available to the subshell are only taken from the Nix store. The
Nix store is where software installed by Nix is… stored, and we don’t want R
to be confused and go look for R packages in the user’s library, which could
happen without this specific &lt;code&gt;.Rprofile&lt;/code&gt; file:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rix_init(
  project_path = path_env_stringr,
  rprofile_action = &amp;quot;overwrite&amp;quot;,
  message_type = &amp;quot;simple&amp;quot;
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## ### Bootstrapping isolated, project-specific, and runtime-pure R setup via Nix ###
## 
## ==&amp;gt; Created isolated nix-R project folder:
##  /home/cbrunos/six_to/dev_env/b-rodrigues.github.com/content/blog/_env_stringr_1.4.1 
## ==&amp;gt; R session running via Nix (nixpkgs)
## * R session not running from RStudio
## ==&amp;gt; Added `.Rprofile` file and code lines for new R sessions launched from:
## /home/cbrunos/six_to/dev_env/b-rodrigues.github.com/content/blog/_env_stringr_1.4.1
## 
## * Added the location of the Nix store to `PATH` environmental variable for new R sessions on host/docker RStudio:
## /nix/var/nix/profiles/default/bin&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We now generate the &lt;code&gt;default.nix&lt;/code&gt; file for that subshell:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rix(
  r_ver = &amp;quot;latest&amp;quot;,
  r_pkgs = &amp;quot;stringr@1.4.1&amp;quot;,
  overwrite = TRUE,
  project_path = path_env_stringr
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice how we use the latest version of R (we could have used any other), but
&lt;code&gt;{stringr}&lt;/code&gt; on version 1.4.1. Finally, we use &lt;code&gt;with_nix()&lt;/code&gt; to evaluate
&lt;code&gt;stringr::str_subset(c(&#34;&#34;, &#34;a&#34;), &#34;&#34;)&lt;/code&gt; inside that subshell:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;out_nix_stringr &amp;lt;- with_nix(
  expr = function() stringr::str_subset(c(&amp;quot;&amp;quot;, &amp;quot;a&amp;quot;), &amp;quot;&amp;quot;),
  program = &amp;quot;R&amp;quot;,
  exec_mode = &amp;quot;non-blocking&amp;quot;,
  project_path = path_env_stringr,
  message_type = &amp;quot;simple&amp;quot;
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## * R session not running from RStudio
## ### Prepare to exchange arguments and globals for `expr` between the host and Nix R sessions ###
## * checking code in `expr` for potential problems:
##  `codetools::checkUsage(fun = expr)`
## 
## * checking code in `expr` for potential problems:
## 
## * checking code in `globals_exprs` for potential problems:
## 
## ==&amp;gt; Running deparsed expression via `nix-shell` in non-blocking mode:
## 
## 
## ==&amp;gt; Process ID (PID) is 19688.
## ==&amp;gt; Receiving stdout and stderr streams...
## 
## ==&amp;gt; `expr` succeeded!
## ### Finished code evaluation in `nix-shell` ###
## 
## * Evaluating `expr` in `nix-shell` returns:
## [1] &amp;quot;a&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we can check if the result is really &lt;code&gt;&#34;a&#34;&lt;/code&gt; or not:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;identical(&amp;quot;a&amp;quot;, out_nix_stringr)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;with_nix()&lt;/code&gt; should work whether you installed your main R session using Nix, or
not, but we’re not sure this is true for Windows (or rather, WSL2): we don’t have
a Windows license to test this on Windows, so if you’re on Windows and use WSL2
and want to test this, we would be very happy to hear from you!&lt;/p&gt;
&lt;p&gt;If you’re interested into using project-specific, and reproducible development
environments, give &lt;code&gt;{rix}&lt;/code&gt; and Nix a try! Learn more about &lt;code&gt;{rix}&lt;/code&gt; on its Github
repository &lt;a href=&#34;https://github.com/b-rodrigues/rix&#34;&gt;here&lt;/a&gt; or
&lt;a href=&#34;https://b-rodrigues.github.io/rix/&#34;&gt;website&lt;/a&gt;. We wrote many vignettes that are
conveniently numbered, so don’t hesitate to &lt;a href=&#34;https://b-rodrigues.github.io/rix/articles/a-getting-started.html&#34;&gt;get
started&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;
Hope you enjoyed! If you found this blog post useful, you might want to follow
me on &lt;a href=&#34;https://fosstodon.org/@brodriguesco&#34;&gt;Mastodon&lt;/a&gt; or &lt;a href=&#34;https://www.twitter.com/brodriguesco&#34;&gt;twitter&lt;/a&gt; for blog post updates and
&lt;a href=&#34;https://www.buymeacoffee.com/brodriguesco&#34;&gt;buy me an espresso&lt;/a&gt; or &lt;a href=&#34;https://www.paypal.me/brodriguesco&#34;&gt;paypal.me&lt;/a&gt;, or buy my &lt;a href=&#34;https://www.brodrigues.co/about/books/&#34;&gt;ebooks&lt;/a&gt;.
You can also watch my videos on &lt;a href=&#34;https://www.youtube.com/c/BrunoRodrigues1988/&#34;&gt;youtube&lt;/a&gt;.
So much content for you to consoom!
&lt;/p&gt;
&lt;style&gt;.bmc-button img{width: 27px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-flex !important;color:#ffffff !important;background-color:#272b30 !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 1px 9px !important;font-size: 22px !important;letter-spacing:0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:&#39;Cookie&#39;, cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#82518c !important;}&lt;/style&gt;
&lt;p&gt;
&lt;link href=&#34;https://fonts.googleapis.com/css?family=Cookie&#34; rel=&#34;stylesheet&#34;&gt;&lt;a class=&#34;bmc-button&#34; target=&#34;_blank&#34; href=&#34;https://www.buymeacoffee.com/brodriguesco&#34;&gt;&lt;img src=&#34;https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg&#34; alt=&#34;Buy me an Espresso&#34;&gt;&lt;span style=&#34;margin-left:5px&#34;&gt;Buy me an Espresso&lt;/span&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Reproducible data science with Nix, part 8 -- nixpkgs, a tale of the magic of free and open source software and a call for charity</title>
      <link>https://www.brodrigues.co/blog/2023-12-19-nix_for_r_part_8/</link>
      <pubDate>Tue, 19 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.brodrigues.co/blog/2023-12-19-nix_for_r_part_8/</guid>
      <description>&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;p&gt;&lt;img src=&#34;https://www.brodrigues.co/img/santa_tux.jpg&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;This is part 8 of a series of blog posts about Nix. Check out
the other parts &lt;a href=&#34;https://www.brodrigues.co/tags/nix/&#34;&gt;here&lt;/a&gt;.
TLDR: free and open source software is one of the most important
common goods with enormous positive externalities: if you want to
help funding it, keep reading!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;I wanted to quickly discuss about &lt;code&gt;nixpkgs&lt;/code&gt;, which is the collection of packages
that can be installed using Nix. Why is a project like Nix and &lt;code&gt;nixpkgs&lt;/code&gt;
important, even if you don’t use Nix? In actuality, you may not realise it, but
you very much benefit from projects like Nix even if you don’t use it. Let me
explain.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nixpkgs&lt;/code&gt; is “just” a Github repository containing thousands upon thousands of
Nix expressions. When installing a package, these expressions get evaluated, and
the package in question gets installed. What &lt;em&gt;installed&lt;/em&gt; means can vary:
sometimes the package gets built from source, sometimes a pre-compiled binary
package for your operating system gets downloaded and installed.&lt;/p&gt;
&lt;p&gt;For example,
&lt;a href=&#34;https://github.com/NixOS/nixpkgs/blob/dce218f4f35440622d2056f93ddc335351763bb4/pkgs/development/libraries/quarto/default.nix&#34;&gt;here&lt;/a&gt;
is the Nix expression that downloads and installs Quarto. This is an example of
an expression that downloads the pre-compiled Quarto package from Quarto’s own
Github repository, and then &lt;em&gt;installs&lt;/em&gt; it. The installation process in this case
is essentially making sure that Quarto is able to find its dependencies, which
also get installed from Nix, and some R and Python packages to make
Quarto work well with both languages also get installed.&lt;/p&gt;
&lt;p&gt;Because Nix packages are “nothing but” Nix expressions hosted on Github,
contributing to Nix is as simple as opening a PR. For example,
&lt;a href=&#34;https://github.com/NixOS/nixpkgs/pull/263108&#34;&gt;here&lt;/a&gt; is a draft PR I opened to
prepare for the imminent release of Quarto &lt;code&gt;1.4&lt;/code&gt;. My goal when I opened this
draft PR was to get used to contributing to &lt;code&gt;nixpkgs&lt;/code&gt; (this was my second or
third PR to &lt;code&gt;nixpkgs&lt;/code&gt;, and I did some rookie mistakes when opening my first
ones) and also to make the latest version of Quarto available on Nix as quickly
as possible. But this PR had an unexpected consequence: through it, we found a
bug in Quarto, which was then fixed before the actual release of the next
version!&lt;/p&gt;
&lt;p&gt;You see, how these things work is that when software gets released, operating
system specific packages get built downstream. In the case of Quarto, this is
not entirely true though: the developers of Quarto release many pre-compiled
packages for Windows, macOS and several Linux distribution themselves. But they
don’t do so for many other operating systems (which is entirely normal: there’s
just too many! So releasing pre-built binaries for the main operating systems is
more than enough), so the maintainers of these other operating systems (or
package managers) have to package the software themselves. In the case of
scientific software like Quarto, this usually means that it must get packaged
for the Conda package manager (popular among Python users) and Nix (and there’s
certainly other package managers out there that provide Quarto for other
&lt;em&gt;exotic&lt;/em&gt; systems) (Note: in the case of Quarto, I think the Quarto devs
themselves also package it for Conda, though).&lt;/p&gt;
&lt;p&gt;Turns out that when trying to package the pre-releases of Quarto for Nix, we
discovered a regression in the upstream code that would not only affect
packaging for Nix, but also for other package managers. We opened an issue on
&lt;a href=&#34;https://github.com/quarto-dev/quarto-cli/issues/7344&#34;&gt;Quarto’s issue tracker&lt;/a&gt;
and after some discussion, the bug was identified and adressed in a matter of
hours. And now everyone gets to enjoy a better version of Quarto!&lt;/p&gt;
&lt;p&gt;This type of thing happens quite a lot in the background of open source
development. My mind always gets blown when I think about the enormous amount of
hours that get put by hobbyists and paid developers into open source and how
well everything works. Truly a Christmas miracle (but one that happens all
around the year)!&lt;/p&gt;
&lt;p&gt;But it’s not all good and perfect. Some software is more complex to package, and
requires much more work. For example the RStudio IDE is one of these. It’s a
complex piece of software with many dependencies, and while it is available on
Nix, it can only be installed on Windows and Linux. If you’re a Nix user on
macOS, you won’t be able to install RStudio, unfortunately. And, unfortunately
also, if you install RStudio using the usual macOS installer, it won’t be able
to find any version of R and R packages installed with Nix. This is because
RStudio needs to be patched to make it work nicely with Nix (just like we have
to patch and prepare Quarto to play well with Nix). And packaging Rstudio for
Nix on macOS requires some expertise and hardware that we R users/contributers
to Nix don’t have all have access to.&lt;/p&gt;
&lt;p&gt;This is where I appeal to your generosity: I have contacted a company called
Numtide which offers a packaging service. You tell them which software you want
on Nix, they write the expression and open a PR to &lt;code&gt;nixpkgs&lt;/code&gt;. But this costs
money: so I started a Gofundme which you can find
&lt;a href=&#34;https://www.gofundme.com/f/package-rstudio-for-nix-on-macos-platforms&#34;&gt;here&lt;/a&gt;
to fund this. The goal is 4500€, which would cover the work, plus Gofundme
fees and interest rate risk. I stated in the Gofundme that if the goal was not
reached until the end of the year, I would donate all the money to the R
foundation, but I might extend it to end of January 2024 instead.&lt;/p&gt;
&lt;p&gt;So here is my ask: if you want to help make free and open source software
better, consider donating to this Gofundme! As explained above, even if you
don’t use Nix, everyone can benefit from work that is done by everyone, be it
upstream or downstream. And if the goal is not met, your donation will go to the
R foundation anyways!&lt;/p&gt;
&lt;p&gt;The link to the Gofundme is
&lt;a href=&#34;https://www.gofundme.com/f/package-rstudio-for-nix-on-macos-platforms&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I hope you can help out with this and make free and open source available and
better for everyone.&lt;/p&gt;
&lt;p&gt;Many thanks, merry Christmas and happy new year!&lt;/p&gt;
&lt;p&gt;
Hope you enjoyed! If you found this blog post useful, you might want to
follow me on &lt;a href=&#34;https://fosstodon.org/@brodriguesco&#34;&gt;Mastodon&lt;/a&gt; or
&lt;a href=&#34;https://www.twitter.com/brodriguesco&#34;&gt;twitter&lt;/a&gt; for blog post updates
and &lt;a href=&#34;https://www.buymeacoffee.com/brodriguesco&#34;&gt;buy me an espresso&lt;/a&gt;
or &lt;a href=&#34;https://www.paypal.me/brodriguesco&#34;&gt;paypal.me&lt;/a&gt;, or buy my
&lt;a href=&#34;https://www.brodrigues.co/about/books/&#34;&gt;ebooks&lt;/a&gt;. You can also watch
my videos on
&lt;a href=&#34;https://www.youtube.com/c/BrunoRodrigues1988/&#34;&gt;youtube&lt;/a&gt;. So much
content for you to consoom!
&lt;/p&gt;
&lt;style&gt;.bmc-button img{width: 27px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-flex !important;color:#ffffff !important;background-color:#272b30 !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 1px 9px !important;font-size: 22px !important;letter-spacing:0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:&#39;Cookie&#39;, cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#82518c !important;}&lt;/style&gt;
&lt;p&gt;
&lt;link href=&#34;https://fonts.googleapis.com/css?family=Cookie&#34; rel=&#34;stylesheet&#34;&gt;&lt;a class=&#34;bmc-button&#34; target=&#34;_blank&#34; href=&#34;https://www.buymeacoffee.com/brodriguesco&#34;&gt;&lt;img src=&#34;https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg&#34; alt=&#34;Buy me an Espresso&#34;/&gt;&lt;span style=&#34;margin-left:5px&#34;&gt;Buy
me an Espresso&lt;/span&gt;&lt;/a&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reproducible data science with Nix, part 7 -- Building a Quarto book using Nix on Github Actions</title>
      <link>https://www.brodrigues.co/blog/2023-10-20-nix_for_r_part7/</link>
      <pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.brodrigues.co/blog/2023-10-20-nix_for_r_part7/</guid>
      <description>&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;p&gt;&lt;img src=&#34;https://www.brodrigues.co/img/nix_users_press_both_buttons.png&#34; width=&#34;50%&#34;&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Back in June I self-published a book on Amazon’s Kindle Direct Publishing
service and wrote a blog post detailling how you could achieve that using
Quarto, which you can read
&lt;a href=&#34;https://www.brodrigues.co/blog/2023-06-29-book_quarto/&#34;&gt;here&lt;/a&gt;. The book is
about &lt;a href=&#34;https://www.brodrigues.co/about/books/&#34;&gt;building reproducible analytical pipelines with
R&lt;/a&gt;. For the purposes of this post I made
a &lt;a href=&#34;https://github.com/b-rodrigues/kdp_quarto&#34;&gt;template on Github&lt;/a&gt; that you could
fork and use as a starting point to write your own book. The book also gets
built using Github Actions each time you push new changes: a website gets built,
an E-book for e-ink devices and a Amazon KDP-ready PDF for print get also built.
That template used dedicated actions to install the required version of R,
Quarto, and R packages (using &lt;code&gt;{renv}&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Let’s take a look at the workflow file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;on:
  push:
    branches: main

name: Render and Publish

jobs:
  build-deploy:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Setup pandoc
        uses: r-lib/actions/setup-pandoc@v2

      - name: Setup R
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: &amp;#39;4.3.1&amp;#39;

      - name: Setup renv
        uses: r-lib/actions/setup-renv@v2

      - name: Set up Quarto
        uses: quarto-dev/quarto-actions/setup@v2
        with:
          # To install LaTeX to build PDF book 
          tinytex: true 
          # uncomment below and fill to pin a version
          #version: 1.3.353

      - name: Publish to GitHub Pages (and render)
        uses: quarto-dev/quarto-actions/publish@v2
        with:
          target: gh-pages
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # this secret is always available for github actions&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, there are a lot of different moving pieces to get this to work.
Since then I discovered Nix (if you’ve not been following my adventures, there’s
6 other parts to this series as of today), and now I wrote another template that
uses Nix to handle the book’s dependencies instead of dedicated actions and
&lt;code&gt;{renv}&lt;/code&gt;. You can find the repository
&lt;a href=&#34;https://github.com/b-rodrigues/quarto_book_nix&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here is what the workflow file looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name: Build book using Nix

on:
  push:
    branches:
      - main
      - master

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout Code
      uses: actions/checkout@v3

    - name: Install Nix
      uses: DeterminateSystems/nix-installer-action@main
      with:
        logger: pretty
        log-directives: nix_installer=trace
        backtrace: full

    - name: Nix cache
      uses: DeterminateSystems/magic-nix-cache-action@main

    - name: Build development environment
      run: |
        nix-build

    - name: Publish to GitHub Pages (and render)
      uses: b-rodrigues/quarto-nix-actions/publish@main
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first thing you should notice is that this file is much shorter.&lt;/p&gt;
&lt;p&gt;The first step, &lt;code&gt;Checkout Code&lt;/code&gt; makes the code available to the rest of the
steps. I then install Nix on this runner using the Determinate Systems
&lt;code&gt;nix-installer-action&lt;/code&gt; and then I use another action from Determinate Systems,
the &lt;code&gt;magic-nix-cache-action&lt;/code&gt;. This action caches all the packages so that they
don’t need to get re-built each time a change gets pushed, speeding up the
process by a lot. The development environment gets then built using &lt;code&gt;nix-build&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Finally, an action I defined runs, &lt;code&gt;quarto-nix-actions/publish&lt;/code&gt;. This is a fork
of the &lt;code&gt;quarto-actions/publish&lt;/code&gt; action which you can find
&lt;a href=&#34;https://github.com/quarto-dev/quarto-actions/blob/main/publish/action.yml&#34;&gt;here&lt;/a&gt;.
My fork simply makes sure that the &lt;code&gt;quarto render&lt;/code&gt; and &lt;code&gt;quarto publish&lt;/code&gt; commands
run in the &lt;a href=&#34;https://github.com/b-rodrigues/quarto-nix-actions/blob/f48f5a7813eb4978a2f557ff45bcc854526fb80b/publish/action.yml#L58&#34;&gt;Nix environment defined for the
project&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can see the book website
&lt;a href=&#34;https://b-rodrigues.github.io/quarto_book_nix/&#34;&gt;here&lt;/a&gt;; read it, it’s explains
everything in much more details than this blog post! But if you’re busy, read
continue reading this blog post instead.&lt;/p&gt;
&lt;p&gt;The obvious next question is why bother with this second, Nix-centric, approach?&lt;/p&gt;
&lt;p&gt;There are at least three reasons. The first is that it is possible to define
so-called &lt;code&gt;default.nix&lt;/code&gt; files that the Nix package manager then uses to build a
fully reproducible development environment. This environment will contain all
the packages that you require, and will not interfere with any other packages
installed on your system. This essentially means that you can have
project-specific &lt;code&gt;default.nix&lt;/code&gt; files, each specifying the requirements for
specific projects. This file can then be used as-is on any other platform to
re-create your environment. The second reason is that when installing a package
that requires system-level dependencies, &lt;code&gt;{rJava}&lt;/code&gt; for example, all the
lower-level dependencies get automatically installed as well. Forget about
reading error messages of &lt;code&gt;install.packages()&lt;/code&gt; to find which system development
library you need to install first. The third reason is that you can pin a
specific revision of &lt;code&gt;nixpkgs&lt;/code&gt; to ensure reproducibility.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;nixpkgs&lt;/code&gt; mono-repository is “just” a Github repository which you can find
here: &lt;a href=&#34;https://github.com/NixOS/nixpkgs&#34;&gt;https://github.com/NixOS/nixpkgs&lt;/a&gt;. This
repository contains Nix expressions to build and install more than 80’000
packages and you can search for installable Nix packages
&lt;a href=&#34;https://search.nixos.org/packages&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Because &lt;code&gt;nixpkgs&lt;/code&gt; is a “just” Github repository, it is possible to use a
specific commit hash to install the packages as they were at a specific point in
time. For example, if you use this commit, &lt;code&gt;7c9cc5a6e&lt;/code&gt;, you’ll get the very
latest packages as of the 19th of October 2023, but if you used this one
instead: &lt;code&gt;976fa3369&lt;/code&gt;, you’ll get packages from the 19th of August 2023.&lt;/p&gt;
&lt;p&gt;This ability to deal with both underlying system-level dependencies and pin
package versions at a specific commit is extremely useful on Git(Dev)Ops
platforms like Github Actions. Debugging installation failures of packages can
be quite frustrating, especially on Github Actions, and especially if you’re not
already familiar with how Linux distributions work. Having a tool that handles
all of that for you is amazing. The difficult part is writing these
&lt;code&gt;default.nix&lt;/code&gt; files that the Nix package manager requires to actually build
these development environments. But don’t worry, with my co-author &lt;a href=&#34;https://github.com/philipp-baumann&#34;&gt;Philipp
Baumann&lt;/a&gt;, we developed an R package called
&lt;code&gt;{rix}&lt;/code&gt; which generates these &lt;code&gt;default.nix&lt;/code&gt; files for you.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{rix}&lt;/code&gt; is an R package that makes it very easy to generate very complex
&lt;code&gt;default.nix&lt;/code&gt; files. These files can in turn be used by the Nix package manager
to build project-specific environments. The book’s Github repository contains a
file called &lt;code&gt;define_env.R&lt;/code&gt; with the following content:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(rix)

rix(r_ver = &amp;quot;4.3.1&amp;quot;,
    r_pkgs = c(&amp;quot;quarto&amp;quot;),
    system_pkgs = &amp;quot;quarto&amp;quot;,
    tex_pkgs = c(
      &amp;quot;amsmath&amp;quot;,
      &amp;quot;framed&amp;quot;,
      &amp;quot;fvextra&amp;quot;,
      &amp;quot;environ&amp;quot;,
      &amp;quot;fontawesome5&amp;quot;,
      &amp;quot;orcidlink&amp;quot;,
      &amp;quot;pdfcol&amp;quot;,
      &amp;quot;tcolorbox&amp;quot;,
      &amp;quot;tikzfill&amp;quot;
    ),
    ide = &amp;quot;other&amp;quot;,
    shell_hook = &amp;quot;&amp;quot;,
    project_path = &amp;quot;.&amp;quot;,
    overwrite = TRUE,
    print = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;{rix}&lt;/code&gt; ships the &lt;code&gt;rix()&lt;/code&gt; function which takes several arguments. These
arguments allow you to specify an R version, a list of R packages, a list of
system packages, TeXLive packages and other options that allow you to specify
your requirements. Running this code generates this &lt;code&gt;default.nix&lt;/code&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# This file was generated by the {rix} R package v0.4.1 on 2023-10-19
# with following call:
# &amp;gt;rix(r_ver = &amp;quot;976fa3369d722e76f37c77493d99829540d43845&amp;quot;,
#  &amp;gt; r_pkgs = c(&amp;quot;quarto&amp;quot;),
#  &amp;gt; system_pkgs = &amp;quot;quarto&amp;quot;,
#  &amp;gt; tex_pkgs = c(&amp;quot;amsmath&amp;quot;,
#  &amp;gt; &amp;quot;framed&amp;quot;,
#  &amp;gt; &amp;quot;fvextra&amp;quot;,
#  &amp;gt; &amp;quot;environ&amp;quot;,
#  &amp;gt; &amp;quot;fontawesome5&amp;quot;,
#  &amp;gt; &amp;quot;orcidlink&amp;quot;,
#  &amp;gt; &amp;quot;pdfcol&amp;quot;,
#  &amp;gt; &amp;quot;tcolorbox&amp;quot;,
#  &amp;gt; &amp;quot;tikzfill&amp;quot;),
#  &amp;gt; ide = &amp;quot;other&amp;quot;,
#  &amp;gt; project_path = &amp;quot;.&amp;quot;,
#  &amp;gt; overwrite = TRUE,
#  &amp;gt; print = TRUE,
#  &amp;gt; shell_hook = &amp;quot;&amp;quot;)
# It uses nixpkgs&amp;#39; revision 976fa3369d722e76f37c77493d99829540d43845 for reproducibility purposes
# which will install R version 4.3.1
# Report any issues to https://github.com/b-rodrigues/rix
let
 pkgs = import (fetchTarball &amp;quot;https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz&amp;quot;) {};
 rpkgs = builtins.attrValues {
  inherit (pkgs.rPackages) quarto;
};
  tex = (pkgs.texlive.combine {
  inherit (pkgs.texlive) scheme-small amsmath framed fvextra environ fontawesome5 orcidlink pdfcol tcolorbox tikzfill;
});
 system_packages = builtins.attrValues {
  inherit (pkgs) R glibcLocalesUtf8 quarto;
};
  in
  pkgs.mkShell {
    LOCALE_ARCHIVE = if pkgs.system == &amp;quot;x86_64-linux&amp;quot; then  &amp;quot;${pkgs.glibcLocalesUtf8}/lib/locale/locale-archive&amp;quot; else &amp;quot;&amp;quot;;
    LANG = &amp;quot;en_US.UTF-8&amp;quot;;
    LC_ALL = &amp;quot;en_US.UTF-8&amp;quot;;
    LC_TIME = &amp;quot;en_US.UTF-8&amp;quot;;
    LC_MONETARY = &amp;quot;en_US.UTF-8&amp;quot;;
    LC_PAPER = &amp;quot;en_US.UTF-8&amp;quot;;
    LC_MEASUREMENT = &amp;quot;en_US.UTF-8&amp;quot;;

    buildInputs = [  rpkgs tex system_packages  ];
  }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This file defines the environment that is needed to build your book: be it
locally on your machine, or on a GitOps platform like Github Actions. All that
matters is that you have the Nix package manager installed (thankfully, it’s
available for Windows –through WSL2–, Linux and macOS).&lt;/p&gt;
&lt;p&gt;Being able to work locally on a specific environment, defined through code, and
use that environment on the cloud as well, is great. It doesn’t matter that the
code runs on Ubuntu on the Github Actions runner, and if that operating system
is not the one you use as well. Thanks to Nix, your code will run on exactly the
same environment. Because of that, you can use &lt;code&gt;ubuntu-latest&lt;/code&gt; as your runner,
because exactly the same packages will always get installed. This is not the
case with my first template that uses dedicated actions and &lt;code&gt;{renv}&lt;/code&gt;: there, the
runner uses &lt;code&gt;ubuntu-22.04&lt;/code&gt;, a fixed version of the Ubuntu operating system. The
risk here, is that once these runners get decommissioned (Ubuntu 22.04 is a
&lt;em&gt;long-term support&lt;/em&gt; release of Ubuntu, so it’ll stop getting updated sometime in
2027), my code won’t be able to run anymore. This is because there’s no
guarantee that the required version of R, Quarto, and all the other packages I
need will be installable on that new release of Ubuntu. So for example, suppose
I have the package &lt;code&gt;{foo}&lt;/code&gt; at version 1.0 that requires the system-level
development library &lt;code&gt;bar-dev&lt;/code&gt; at version 0.4 to be installed on Ubuntu. This is
not an issue now, as Ubuntu 22.04 ships version 0.4 of &lt;code&gt;bar-dev&lt;/code&gt;. But it is very
unlikely that the future version of Ubuntu from 2027 will ship that version, and
there’s no guarantee my package will successfully build and work as expected
with a more recent version of &lt;code&gt;bar-dev&lt;/code&gt;. With Nix, this is not an issue; because
I pin a specific commit of &lt;code&gt;nixpkgs&lt;/code&gt;, not only will &lt;code&gt;{foo}&lt;/code&gt; at version 1.0 get
installed, its dependency &lt;code&gt;bar-dev&lt;/code&gt; at version 0.4 will get installed by Nix as
well, and get used to build &lt;code&gt;{foo}&lt;/code&gt;. It doesn’t matter that my underlying
operating system ships a more recent version of &lt;code&gt;bar-dev&lt;/code&gt;. I really insist on
this point, because this is not something that you can easily deal with, even
with Docker. This is because when you use Docker, you need to be able to rebuild
the image as many times as you need (the alternative is to store, forever, the
built image), and just like for Github Actions runners, the underlying Ubuntu
image will be decommissioned and stop working one day.&lt;/p&gt;
&lt;p&gt;In other words, if you need long-term reproducibility, you should really
consider using Nix, and even if you don’t need long-term reproducibility, you
should really consider using Nix. This is because Nix makes things much easier.
But there is one point where Nix is at a huge disadvantage when compared to the
alternatives: the entry cost is quite high, as I’ve discussed in my &lt;a href=&#34;https://www.brodrigues.co/blog/2023-10-05-repro_overview/&#34;&gt;previous
blog post&lt;/a&gt;. But I’m
hoping that through my blog posts, this entry cost is getting lowered for R
users!&lt;/p&gt;
&lt;p&gt;
Hope you enjoyed! If you found this blog post useful, you might want to follow
me on &lt;a href=&#34;https://fosstodon.org/@brodriguesco&#34;&gt;Mastodon&lt;/a&gt; or &lt;a href=&#34;https://www.twitter.com/brodriguesco&#34;&gt;twitter&lt;/a&gt; for blog post updates and
&lt;a href=&#34;https://www.buymeacoffee.com/brodriguesco&#34;&gt;buy me an espresso&lt;/a&gt; or &lt;a href=&#34;https://www.paypal.me/brodriguesco&#34;&gt;paypal.me&lt;/a&gt;, or buy my &lt;a href=&#34;https://www.brodrigues.co/about/books/&#34;&gt;ebooks&lt;/a&gt;.
You can also watch my videos on &lt;a href=&#34;https://www.youtube.com/c/BrunoRodrigues1988/&#34;&gt;youtube&lt;/a&gt;.
So much content for you to consoom!
&lt;/p&gt;
&lt;style&gt;.bmc-button img{width: 27px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-flex !important;color:#ffffff !important;background-color:#272b30 !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 1px 9px !important;font-size: 22px !important;letter-spacing:0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:&#39;Cookie&#39;, cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#82518c !important;}&lt;/style&gt;
&lt;p&gt;
&lt;link href=&#34;https://fonts.googleapis.com/css?family=Cookie&#34; rel=&#34;stylesheet&#34;&gt;&lt;a class=&#34;bmc-button&#34; target=&#34;_blank&#34; href=&#34;https://www.buymeacoffee.com/brodriguesco&#34;&gt;&lt;img src=&#34;https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg&#34; alt=&#34;Buy me an Espresso&#34;&gt;&lt;span style=&#34;margin-left:5px&#34;&gt;Buy me an Espresso&lt;/span&gt;&lt;/a&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reproducible data science with Nix, part 6 -- CI/CD has never been easier</title>
      <link>https://www.brodrigues.co/blog/2023-09-20-nix_for_r_part6/</link>
      <pubDate>Wed, 20 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.brodrigues.co/blog/2023-09-20-nix_for_r_part6/</guid>
      <description>&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;p&gt;&lt;img src=&#34;https://www.brodrigues.co/img/gymnastics.png&#34; width=&#34;50%&#34;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Warning: I highly recommend you read this &lt;a href=&#34;https://www.brodrigues.co/blog/2023-07-19-nix_for_r_part2/&#34;&gt;blog
post&lt;/a&gt; first, which
will explain how to run a pipeline inside Nix in detail. This blog post will
assume that you’ve read that one, and it would also help if you’re familiar with
Github Actions, if not, read this &lt;a href=&#34;https://www.brodrigues.co/blog/2022-11-19-raps/&#34;&gt;other blog post of mine as
well&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This is getting ridiculous. The meme that I’m using as a header for this blog
post perfectly summaries how I feel.&lt;/p&gt;
&lt;p&gt;This will be a short blog post, because Nix makes things so easy that there’s
not much to say. I wanted to try how I could use Nix on Github Actions to run a
reproducible pipeline. This pipeline downloads some data, prepares it, and fits
a machine learning model. It is code that I had laying around from an old video
on the now deprecated &lt;code&gt;{drake}&lt;/code&gt; package, &lt;code&gt;{targets}&lt;/code&gt; predecessor.&lt;/p&gt;
&lt;p&gt;You can find the pipeline
&lt;a href=&#34;https://github.com/b-rodrigues/nix_ml_cicd_demo/tree/main&#34;&gt;here&lt;/a&gt;
and you can also take a look at the same pipeline but which uses Docker
&lt;a href=&#34;https://github.com/b-rodrigues/mlops_demo&#34;&gt;here&lt;/a&gt;
for comparison purposes.&lt;/p&gt;
&lt;p&gt;What I wanted to achieve was the following: I wanted to set up a reproducible
environment with Nix on my computer, work on my pipeline locally, and then have
it run on Github Actions as well. But I wanted my pipeline to run exactly on the
same environment as the one I was using to develop it. In a world without Nix,
this means using a mix of &lt;code&gt;{renv}&lt;/code&gt; (or &lt;code&gt;{groundhog}&lt;/code&gt; or &lt;code&gt;{rang}&lt;/code&gt;) and a Docker
image that ships the right version of R. I would then need to write a Github
Actions workflow file that builds that Docker image, then runs it and saves the
outputs as artifacts. Also, in practice that image would not be exactly the same
as my local environment: I would have the same version of R and R packages, but
every other system-level dependency would be a different version unless I use
that Dockerized environment to develop locally, something I suggested you should
do merely &lt;a href=&#34;https://www.brodrigues.co/blog/2023-05-08-dock_dev_env/&#34;&gt;4 months
ago&lt;/a&gt; (oooh, how blind
was I!).&lt;/p&gt;
&lt;p&gt;With Nix, not only can I take care of the version of R and R packages with one
single tool but also every underlying system-level dependency gets handled by
Nix. So if I use a package that requires, say, Java, or GDAL, or any other of
these usual suspects that make installing their R bindings so tricky, Nix will
handle this for me without any intervention on my part. I can also use this
environment to develop locally, and then, once I’m done working locally,
&lt;em&gt;exactly&lt;/em&gt; this environment, &lt;em&gt;exactly&lt;/em&gt; every bit of that environment, will get
rebuilt and used to run my code on Github Actions.&lt;/p&gt;
&lt;p&gt;So &lt;a href=&#34;https://github.com/b-rodrigues/nix_ml_cicd_demo&#34;&gt;this is the repository&lt;/a&gt;
where you can find the code. There’s a &lt;code&gt;{targets}&lt;/code&gt; script that defines the
pipeline and a &lt;code&gt;functions/&lt;/code&gt; folder with some code that I wrote for said
pipeline. What’s unfamiliar to you (unless you’ve been reading my Nix adventures
since the beginning) is the &lt;code&gt;default.nix&lt;/code&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let
 pkgs = import (fetchTarball &amp;quot;https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz&amp;quot;) {};
 rpkgs = builtins.attrValues {
  inherit (pkgs.rPackages) tidymodels vetiver targets xgboost;
};
 system_packages = builtins.attrValues {
  inherit (pkgs) R;
};
in
 pkgs.mkShell {
  buildInputs = [  rpkgs system_packages  ];
 }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This few lines of code define an environment that pulls packages from revision
&lt;code&gt;976fa3369d722e76f37c77493d99829540d43845&lt;/code&gt; of &lt;code&gt;nixpkgs&lt;/code&gt;. It installs the
packages &lt;code&gt;{tidymodels}&lt;/code&gt;, &lt;code&gt;{vetiver}&lt;/code&gt;, &lt;code&gt;{targets}&lt;/code&gt; and &lt;code&gt;{xgboost}&lt;/code&gt; (actually, I’m
not using &lt;code&gt;{vetiver}&lt;/code&gt; for this &lt;em&gt;yet&lt;/em&gt;, so it could even be removed). Then it also
installs R. Because we’re using that specific revision of Nix, exactly the same
packages (and their dependencies) will get installed, regardless of when we
build this environment. I want to insist that this file is 12 lines long and it
defines a complete environment. The equivalent &lt;code&gt;Dockerfile&lt;/code&gt; is much longer, and
not even completely reproducible, and I would have needed external tools like
&lt;code&gt;{renv}&lt;/code&gt; (or use the Posit CRAN mirror dated snapshots) as you can check out
&lt;a href=&#34;https://github.com/b-rodrigues/mlops_demo&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let’s now turn our attention to the workflow file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name: train_model

on:
  push:
    branches: [main]

jobs:
  targets:
    runs-on: ubuntu-latest
    env:
      GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
    steps:

      - uses: actions/checkout@v3

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main
        with:
          logger: pretty
          log-directives: nix_installer=trace
          backtrace: full

      - name: Nix cache
        uses: DeterminateSystems/magic-nix-cache-action@main

      - name: Build development environment
        run: |
          nix-build

      - name: Check if previous runs exists
        id: runs-exist
        run: git ls-remote --exit-code --heads origin targets-runs
        continue-on-error: true

      - name: Checkout previous run
        if: steps.runs-exist.outcome == &amp;#39;success&amp;#39;
        uses: actions/checkout@v2
        with:
          ref: targets-runs
          fetch-depth: 1
          path: .targets-runs

      - name: Restore output files from the previous run
        if: steps.runs-exist.outcome == &amp;#39;success&amp;#39;
        run: |
          nix-shell default.nix --run &amp;quot;Rscript -e &amp;#39;for (dest in scan(\&amp;quot;.targets-runs/.targets-files\&amp;quot;, what = character())) {
            source &amp;lt;- file.path(\&amp;quot;.targets-runs\&amp;quot;, dest)
            if (!file.exists(dirname(dest))) dir.create(dirname(dest), recursive = TRUE)
            if (file.exists(source)) file.rename(source, dest)
          }&amp;#39;&amp;quot;

      - name: Run model
        run: |
          nix-shell default.nix --run &amp;quot;Rscript -e &amp;#39;targets::tar_make()&amp;#39;&amp;quot;

      - name: Identify files that the targets pipeline produced
        run: git ls-files -mo --exclude=renv &amp;gt; .targets-files

      - name: Create the runs branch if it does not already exist
        if: steps.runs-exist.outcome != &amp;#39;success&amp;#39;
        run: git checkout --orphan targets-runs

      - name: Put the worktree in the runs branch if the latter already exists
        if: steps.runs-exist.outcome == &amp;#39;success&amp;#39;
        run: |
          rm -r .git
          mv .targets-runs/.git .
          rm -r .targets-runs

      - name: Upload latest run
        run: |
          git config --local user.name &amp;quot;GitHub Actions&amp;quot;
          git config --local user.email &amp;quot;actions@github.com&amp;quot;
          rm -r .gitignore .github/workflows
          git add --all -- &amp;#39;:!renv&amp;#39;
          for file in $(git ls-files -mo --exclude=renv)
          do
            git add --force $file
          done
          git commit -am &amp;quot;Run pipeline&amp;quot;
          git push origin targets-runs

      - name: Prepare failure artifact
        if: failure()
        run: rm -rf .git .github .targets-files .targets-runs

      - name: Post failure artifact
        if: failure()
        uses: actions/upload-artifact@main
        with:
          name: ${{ runner.os }}-r${{ matrix.config.r }}-results
          path: .&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The workflow file above is heavily inspired from the one you get when you run
&lt;code&gt;targets::tar_github_actions()&lt;/code&gt;. Running this puts the following
&lt;a href=&#34;https://github.com/ropensci/targets/blob/22103e19584ea15ae44328c07bc9d2699b004a47/inst/templates/github_actions.yaml&#34;&gt;file&lt;/a&gt;
on the root of your &lt;code&gt;{targets}&lt;/code&gt; project. This file is a Github Actions workflow
file, which means that each time you push your code on Github, the pipeline will
run in the cloud. However it needs you to use &lt;code&gt;{renv}&lt;/code&gt; with the project so that
the right packages get installed. You’ll also see a step called &lt;code&gt;Install Linux dependencies&lt;/code&gt; which you will have to adapt to your project.&lt;/p&gt;
&lt;p&gt;All of this can be skipped when using Nix. All that must be done is installing
Nix itself, using the &lt;code&gt;nix-installer-action&lt;/code&gt; from Determinate Systems, then
using the &lt;code&gt;magic-nix-cache-action&lt;/code&gt; which caches the downloaded packages so we
don’t need to wait for the environment to build each time we push (unless we
changed the environment of course) and that’s about it. We then build the
environment on Github Actions using &lt;code&gt;nix-build&lt;/code&gt; and then run the pipeline using
&lt;code&gt;nix-shell default.nix --run &#34;Rscript -e &#39;targets::tar_make()&#39;&#34;&lt;/code&gt;. All the other
steps are copied almost verbatim from the linked file above and make sure that
the computed targets only get recomputed if I edit anything that impacts them,
and also that they get pushed into a branch called &lt;code&gt;targets-runs&lt;/code&gt;. I say &lt;em&gt;copied
almost verbatim&lt;/em&gt; because some steps must run inside R, so we need to specify
that we want to use the R that is available through the Nix environment we just
built.&lt;/p&gt;
&lt;p&gt;Now, each time we push, the following happens:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if we didn’t change anything to &lt;code&gt;default.nix&lt;/code&gt;, the environment gets retrieved from the cache. If we did change something, then environment gets rebuilt (or rather, only the parts that need to be rebuilt, the rest will still get retrieved from the cache)&lt;/li&gt;
&lt;li&gt;if we didn’t change anything to the &lt;code&gt;_targets.R&lt;/code&gt; pipeline itself, then every target will get skipped. If not, only the targets that need to get recomputed will get recomputed.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;One last thing that I didn’t mention: on line 9 you’ll see this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;runs-on: ubuntu-latest&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;this means that the Github Actions will run on the latest available version of
Ubuntu, which is obviously not fixed. When the next LTS gets released in April
2024, this pipeline will be running on Ubuntu 24.04 instead of the current LTS,
version 22.04. This is not good practice because we don’t want the underlying
operating system to be changing, because this could have an impact on the
reproducibility of our pipeline. But with Nix, this &lt;strong&gt;does not matter&lt;/strong&gt;.
Remember that we are using a specific revision of &lt;code&gt;nixpkgs&lt;/code&gt; for our pipeline, so
the &lt;em&gt;exact&lt;/em&gt; same version of not only R and R packages gets installed, but every
underlying piece of software that needs to be available will be installed as
well. We could be running this in 50 years on Ubuntu LTS 74.04 and it would
still install the same stuff and run the same code and produce exactly the same
results.&lt;/p&gt;
&lt;p&gt;This is really bonkers.&lt;/p&gt;
&lt;p&gt;Nix is an incredibly powerful tool. I’ve been exploring and using it for 3
months now, but if something impresses me more than how useful it is, is how
terribly unknown it still is. I hope that this series of blog posts will
motivate other people to learn it.&lt;/p&gt;
&lt;p&gt;
Hope you enjoyed! If you found this blog post useful, you might want to follow
me on &lt;a href=&#34;https://fosstodon.org/@brodriguesco&#34;&gt;Mastodon&lt;/a&gt; or &lt;a href=&#34;https://www.twitter.com/brodriguesco&#34;&gt;twitter&lt;/a&gt; for blog post updates and
&lt;a href=&#34;https://www.buymeacoffee.com/brodriguesco&#34;&gt;buy me an espresso&lt;/a&gt; or &lt;a href=&#34;https://www.paypal.me/brodriguesco&#34;&gt;paypal.me&lt;/a&gt;, or buy my &lt;a href=&#34;https://www.brodrigues.co/about/books/&#34;&gt;ebooks&lt;/a&gt;.
You can also watch my videos on &lt;a href=&#34;https://www.youtube.com/c/BrunoRodrigues1988/&#34;&gt;youtube&lt;/a&gt;.
So much content for you to consoom!
&lt;/p&gt;
&lt;style&gt;.bmc-button img{width: 27px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-flex !important;color:#ffffff !important;background-color:#272b30 !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 1px 9px !important;font-size: 22px !important;letter-spacing:0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:&#39;Cookie&#39;, cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#82518c !important;}&lt;/style&gt;
&lt;p&gt;
&lt;link href=&#34;https://fonts.googleapis.com/css?family=Cookie&#34; rel=&#34;stylesheet&#34;&gt;&lt;a class=&#34;bmc-button&#34; target=&#34;_blank&#34; href=&#34;https://www.buymeacoffee.com/brodriguesco&#34;&gt;&lt;img src=&#34;https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg&#34; alt=&#34;Buy me an Espresso&#34;&gt;&lt;span style=&#34;margin-left:5px&#34;&gt;Buy me an Espresso&lt;/span&gt;&lt;/a&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reproducible data science with Nix, part 5 -- Reproducible literate programming with Nix and Quarto</title>
      <link>https://www.brodrigues.co/blog/2023-09-15-nix_for_r_part5/</link>
      <pubDate>Fri, 15 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.brodrigues.co/blog/2023-09-15-nix_for_r_part5/</guid>
      <description>&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;p&gt;&lt;img src=&#34;https://www.brodrigues.co/img/ayylmao.png&#34; max-width=&#34;100%&#34;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;This blog post is a copy-paste from &lt;a href=&#34;https://b-rodrigues.github.io/rix/articles/building-an-environment-for-literate-programming.html&#34;&gt;this vignette&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div id=&#34;introduction&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;This vignette will walk you through setting up a development environment with
&lt;code&gt;{rix}&lt;/code&gt; that can be used to compile Quarto documents into PDFs. We are going to
use the &lt;a href=&#34;https://github.com/quarto-journals/jss&#34;&gt;Quarto template for the JSS&lt;/a&gt; to
illustrate the process. The first section will show a simple way of achieving
this, which will also be ideal for interactive development (writing the doc).
The second section will discuss a way to build the document in a completely
reproducible manner once it’s done.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;starting-with-the-basics-simple-but-not-entirely-reproducible&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Starting with the basics (simple but not entirely reproducible)&lt;/h2&gt;
&lt;p&gt;This approach will not be the most optimal, but it will be the simplest. We will
start by building a development environment with all our dependencies, and we
can then use it to compile our document interactively. But this approach is not
quite reproducible and requires manual actions. In the next section we will show
you to build a 100% reproducible document in a single command.&lt;/p&gt;
&lt;p&gt;Since we need both the &lt;code&gt;{quarto}&lt;/code&gt; R package as well as the &lt;code&gt;quarto&lt;/code&gt; engine, we
add both of them to the &lt;code&gt;r_pkgs&lt;/code&gt; and &lt;code&gt;system_pkgs&lt;/code&gt; of arguments of &lt;code&gt;{rix}&lt;/code&gt;.
Because we want to compile a PDF, we also need to have &lt;code&gt;texlive&lt;/code&gt; installed, as
well as some LaTeX packages. For this, we use the &lt;code&gt;tex_pkgs&lt;/code&gt; argument:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(rix)

path_default_nix &amp;lt;- tempdir()

rix(r_ver = &amp;quot;4.3.1&amp;quot;,
    r_pkgs = c(&amp;quot;quarto&amp;quot;),
    system_pkgs = &amp;quot;quarto&amp;quot;,
    tex_pkgs = c(&amp;quot;amsmath&amp;quot;),
    ide = &amp;quot;other&amp;quot;,
    shell_hook = &amp;quot;&amp;quot;,
    project_path = path_default_nix,
    overwrite = TRUE,
    print = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # This file was generated by the {rix} R package v0.4.1 on 2023-12-19
## # with following call:
## # &amp;gt;rix(r_ver = &amp;quot;976fa3369d722e76f37c77493d99829540d43845&amp;quot;,
## #  &amp;gt; r_pkgs = c(&amp;quot;quarto&amp;quot;),
## #  &amp;gt; system_pkgs = &amp;quot;quarto&amp;quot;,
## #  &amp;gt; tex_pkgs = c(&amp;quot;amsmath&amp;quot;),
## #  &amp;gt; ide = &amp;quot;other&amp;quot;,
## #  &amp;gt; project_path = path_default_nix,
## #  &amp;gt; overwrite = TRUE,
## #  &amp;gt; print = TRUE,
## #  &amp;gt; shell_hook = &amp;quot;&amp;quot;)
## # It uses nixpkgs&amp;#39; revision 976fa3369d722e76f37c77493d99829540d43845 for reproducibility purposes
## # which will install R version 4.3.1
## # Report any issues to https://github.com/b-rodrigues/rix
## let
##  pkgs = import (fetchTarball &amp;quot;https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz&amp;quot;) {};
##  rpkgs = builtins.attrValues {
##   inherit (pkgs.rPackages) quarto;
## };
##   tex = (pkgs.texlive.combine {
##   inherit (pkgs.texlive) scheme-small amsmath;
## });
##  system_packages = builtins.attrValues {
##   inherit (pkgs) R glibcLocalesUtf8 quarto;
## };
##   in
##   pkgs.mkShell {
##     LOCALE_ARCHIVE = if pkgs.system == &amp;quot;x86_64-linux&amp;quot; then  &amp;quot;${pkgs.glibcLocalesUtf8}/lib/locale/locale-archive&amp;quot; else &amp;quot;&amp;quot;;
##     LANG = &amp;quot;en_US.UTF-8&amp;quot;;
##     LC_ALL = &amp;quot;en_US.UTF-8&amp;quot;;
##     LC_TIME = &amp;quot;en_US.UTF-8&amp;quot;;
##     LC_MONETARY = &amp;quot;en_US.UTF-8&amp;quot;;
##     LC_PAPER = &amp;quot;en_US.UTF-8&amp;quot;;
##     LC_MEASUREMENT = &amp;quot;en_US.UTF-8&amp;quot;;
## 
##     buildInputs = [  rpkgs tex system_packages  ];
##       
##   }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Save these lines into a script called &lt;code&gt;build_env.R&lt;/code&gt; for instance, and run the
script into a new folder made for this project.)&lt;/p&gt;
&lt;p&gt;By default, &lt;code&gt;{rix}&lt;/code&gt; will install the “small” version of the &lt;code&gt;texlive&lt;/code&gt;
distribution available on Nix. To see which &lt;code&gt;texlive&lt;/code&gt; packages get installed
with this small version, you can click
&lt;a href=&#34;https://search.nixos.org/packages?channel=unstable&amp;amp;show=texlive.combined.scheme-small&amp;amp;from=0&amp;amp;size=50&amp;amp;sort=relevance&amp;amp;type=packages&amp;amp;query=scheme-small&#34;&gt;here&lt;/a&gt;.
We start by adding the &lt;code&gt;amsmath&lt;/code&gt; package then build the environment using:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nix_build()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, drop into the Nix shell with &lt;code&gt;nix-shell&lt;/code&gt;, and run &lt;code&gt;quarto add quarto-journals/jss&lt;/code&gt;. This will install the template linked above. Then, in the
folder that contains &lt;code&gt;build_env.R&lt;/code&gt;, the generated &lt;code&gt;default.nix&lt;/code&gt; and &lt;code&gt;result&lt;/code&gt;
download the following files from
&lt;a href=&#34;https://github.com/quarto-journals/jss/&#34;&gt;here&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;article-visualization.pdf&lt;/li&gt;
&lt;li&gt;bibliography.bib&lt;/li&gt;
&lt;li&gt;template.qmd&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;and try to compile &lt;code&gt;template.qmd&lt;/code&gt; by running:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;quarto render template.qmd --to jss-pdf&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You should get the following error message:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Quitting from lines 99-101 [unnamed-chunk-1] (template.qmd)
Error in `find.package()`:
! there is no package called &amp;#39;MASS&amp;#39;
Backtrace:
 1. utils::data(&amp;quot;quine&amp;quot;, package = &amp;quot;MASS&amp;quot;)
 2. base::find.package(package, lib.loc, verbose = verbose)
Execution halted
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So there’s an R chunk in &lt;code&gt;template.qmd&lt;/code&gt; that uses the &lt;code&gt;{MASS}&lt;/code&gt; package. Change
&lt;code&gt;build_env.R&lt;/code&gt; to generate a new &lt;code&gt;default.nix&lt;/code&gt; file that will now add &lt;code&gt;{MASS}&lt;/code&gt; to
the environment when built:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rix(r_ver = &amp;quot;4.3.1&amp;quot;,
    r_pkgs = c(&amp;quot;quarto&amp;quot;, &amp;quot;MASS&amp;quot;),
    system_pkgs = &amp;quot;quarto&amp;quot;,
    tex_pkgs = c(&amp;quot;amsmath&amp;quot;),
    ide = &amp;quot;other&amp;quot;,
    shell_hook = &amp;quot;&amp;quot;,
    project_path = path_default_nix,
    overwrite = TRUE,
    print = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # This file was generated by the {rix} R package v0.4.1 on 2023-12-19
## # with following call:
## # &amp;gt;rix(r_ver = &amp;quot;976fa3369d722e76f37c77493d99829540d43845&amp;quot;,
## #  &amp;gt; r_pkgs = c(&amp;quot;quarto&amp;quot;,
## #  &amp;gt; &amp;quot;MASS&amp;quot;),
## #  &amp;gt; system_pkgs = &amp;quot;quarto&amp;quot;,
## #  &amp;gt; tex_pkgs = c(&amp;quot;amsmath&amp;quot;),
## #  &amp;gt; ide = &amp;quot;other&amp;quot;,
## #  &amp;gt; project_path = path_default_nix,
## #  &amp;gt; overwrite = TRUE,
## #  &amp;gt; print = TRUE,
## #  &amp;gt; shell_hook = &amp;quot;&amp;quot;)
## # It uses nixpkgs&amp;#39; revision 976fa3369d722e76f37c77493d99829540d43845 for reproducibility purposes
## # which will install R version 4.3.1
## # Report any issues to https://github.com/b-rodrigues/rix
## let
##  pkgs = import (fetchTarball &amp;quot;https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz&amp;quot;) {};
##  rpkgs = builtins.attrValues {
##   inherit (pkgs.rPackages) quarto MASS;
## };
##   tex = (pkgs.texlive.combine {
##   inherit (pkgs.texlive) scheme-small amsmath;
## });
##  system_packages = builtins.attrValues {
##   inherit (pkgs) R glibcLocalesUtf8 quarto;
## };
##   in
##   pkgs.mkShell {
##     LOCALE_ARCHIVE = if pkgs.system == &amp;quot;x86_64-linux&amp;quot; then  &amp;quot;${pkgs.glibcLocalesUtf8}/lib/locale/locale-archive&amp;quot; else &amp;quot;&amp;quot;;
##     LANG = &amp;quot;en_US.UTF-8&amp;quot;;
##     LC_ALL = &amp;quot;en_US.UTF-8&amp;quot;;
##     LC_TIME = &amp;quot;en_US.UTF-8&amp;quot;;
##     LC_MONETARY = &amp;quot;en_US.UTF-8&amp;quot;;
##     LC_PAPER = &amp;quot;en_US.UTF-8&amp;quot;;
##     LC_MEASUREMENT = &amp;quot;en_US.UTF-8&amp;quot;;
## 
##     buildInputs = [  rpkgs tex system_packages  ];
##       
##   }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Trying to compile the document results now in another error message:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compilation failed- no matching packages
LaTeX Error: File `orcidlink.sty&amp;#39; not found&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This means that the LaTeX &lt;code&gt;orcidlink&lt;/code&gt; package is missing, and we can solve the
problem by adding &lt;code&gt;&#34;orcidlink&#34;&lt;/code&gt; to the list of &lt;code&gt;tex_pkgs&lt;/code&gt;. Rebuild the
environment and try again to compile the template. Trying again yields a new
error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compilation failed- no matching packages
LaTeX Error: File `tcolorbox.sty&amp;#39; not found.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just as before, add the &lt;code&gt;tcolorbox&lt;/code&gt; package to the list of &lt;code&gt;tex_pkgs&lt;/code&gt;. You will
need to do this several times for some other packages. There is unfortunately no
easier way to list the dependencies and requirements of a LaTeX document.&lt;/p&gt;
&lt;p&gt;This is what the final script to build the environment looks like:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rix(r_ver = &amp;quot;4.3.1&amp;quot;,
    r_pkgs = c(&amp;quot;quarto&amp;quot;, &amp;quot;MASS&amp;quot;),
    system_pkgs = &amp;quot;quarto&amp;quot;,
    tex_pkgs = c(
      &amp;quot;amsmath&amp;quot;,
      &amp;quot;environ&amp;quot;,
      &amp;quot;fontawesome5&amp;quot;,
      &amp;quot;orcidlink&amp;quot;,
      &amp;quot;pdfcol&amp;quot;,
      &amp;quot;tcolorbox&amp;quot;,
      &amp;quot;tikzfill&amp;quot;
    ),
    ide = &amp;quot;other&amp;quot;,
    shell_hook = &amp;quot;&amp;quot;,
    project_path = path_default_nix,
    overwrite = TRUE,
    print = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # This file was generated by the {rix} R package v0.4.1 on 2023-12-19
## # with following call:
## # &amp;gt;rix(r_ver = &amp;quot;976fa3369d722e76f37c77493d99829540d43845&amp;quot;,
## #  &amp;gt; r_pkgs = c(&amp;quot;quarto&amp;quot;,
## #  &amp;gt; &amp;quot;MASS&amp;quot;),
## #  &amp;gt; system_pkgs = &amp;quot;quarto&amp;quot;,
## #  &amp;gt; tex_pkgs = c(&amp;quot;amsmath&amp;quot;,
## #  &amp;gt; &amp;quot;environ&amp;quot;,
## #  &amp;gt; &amp;quot;fontawesome5&amp;quot;,
## #  &amp;gt; &amp;quot;orcidlink&amp;quot;,
## #  &amp;gt; &amp;quot;pdfcol&amp;quot;,
## #  &amp;gt; &amp;quot;tcolorbox&amp;quot;,
## #  &amp;gt; &amp;quot;tikzfill&amp;quot;),
## #  &amp;gt; ide = &amp;quot;other&amp;quot;,
## #  &amp;gt; project_path = path_default_nix,
## #  &amp;gt; overwrite = TRUE,
## #  &amp;gt; print = TRUE,
## #  &amp;gt; shell_hook = &amp;quot;&amp;quot;)
## # It uses nixpkgs&amp;#39; revision 976fa3369d722e76f37c77493d99829540d43845 for reproducibility purposes
## # which will install R version 4.3.1
## # Report any issues to https://github.com/b-rodrigues/rix
## let
##  pkgs = import (fetchTarball &amp;quot;https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz&amp;quot;) {};
##  rpkgs = builtins.attrValues {
##   inherit (pkgs.rPackages) quarto MASS;
## };
##   tex = (pkgs.texlive.combine {
##   inherit (pkgs.texlive) scheme-small amsmath environ fontawesome5 orcidlink pdfcol tcolorbox tikzfill;
## });
##  system_packages = builtins.attrValues {
##   inherit (pkgs) R glibcLocalesUtf8 quarto;
## };
##   in
##   pkgs.mkShell {
##     LOCALE_ARCHIVE = if pkgs.system == &amp;quot;x86_64-linux&amp;quot; then  &amp;quot;${pkgs.glibcLocalesUtf8}/lib/locale/locale-archive&amp;quot; else &amp;quot;&amp;quot;;
##     LANG = &amp;quot;en_US.UTF-8&amp;quot;;
##     LC_ALL = &amp;quot;en_US.UTF-8&amp;quot;;
##     LC_TIME = &amp;quot;en_US.UTF-8&amp;quot;;
##     LC_MONETARY = &amp;quot;en_US.UTF-8&amp;quot;;
##     LC_PAPER = &amp;quot;en_US.UTF-8&amp;quot;;
##     LC_MEASUREMENT = &amp;quot;en_US.UTF-8&amp;quot;;
## 
##     buildInputs = [  rpkgs tex system_packages  ];
##       
##   }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The template will now compile with this environment. To look for a LaTeX
package, you can use the &lt;a href=&#34;https://ctan.org/pkg/orcidlink?lang=en&#34;&gt;search engine on
CTAN&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As stated in the beginning of this section, this approach is not the most
optimal, but it has its merits, especially if you’re still working on the
document. Once the environment is set up, you can simply work on the doc and
compile it as needed using &lt;code&gt;quarto render&lt;/code&gt;. In the next section, we will explain
how to build a 100% reproducible document.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;reproducible-literate-programming&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;100% reproducible literate programming&lt;/h2&gt;
&lt;p&gt;Let’s not forget that Nix is not just a package manager, but also a programming
language. The &lt;code&gt;default.nix&lt;/code&gt; files that &lt;code&gt;{rix}&lt;/code&gt; generates are written in this
language, which was made entirely for the purpose of building software. If you
are not a developer, you may not realise it but the process of compiling a
Quarto or LaTeX document is very similar to the process of building any piece of
software. So we can use Nix to compile a document in a completely reproducible
environment.&lt;/p&gt;
&lt;p&gt;First, let’s fork the repo that contains the Quarto template we need. We will
fork &lt;a href=&#34;https://github.com/quarto-journals/jss&#34;&gt;this repo&lt;/a&gt;. This repo contains the
&lt;code&gt;template.qmd&lt;/code&gt; file that we can change (which is why we fork it, in practice we
would replace this &lt;code&gt;template.qmd&lt;/code&gt; by our own, finished, source &lt;code&gt;.qmd&lt;/code&gt; file). Now
we need to change our &lt;code&gt;default.nix&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let
 pkgs = import (fetchTarball &amp;quot;https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz&amp;quot;) {};
 rpkgs = builtins.attrValues {
   inherit (pkgs.rPackages) quarto MASS;
 };
 tex = (pkgs.texlive.combine {
   inherit (pkgs.texlive) scheme-small amsmath environ fontawesome5 orcidlink pdfcol tcolorbox tikzfill;
 });
 system_packages = builtins.attrValues {
   inherit (pkgs) R quarto;
 };
 in
 pkgs.mkShell {
   buildInputs = [  rpkgs tex system_packages  ];
 }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to the following:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let
 pkgs = import (fetchTarball &amp;quot;https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz&amp;quot;) {};
 rpkgs = builtins.attrValues {
  inherit (pkgs.rPackages) quarto MASS;
 };
 tex = (pkgs.texlive.combine {
  inherit (pkgs.texlive) scheme-small amsmath environ fontawesome5 orcidlink pdfcol tcolorbox tikzfill;
 });
 system_packages = builtins.attrValues {
  inherit (pkgs) R quarto;
 };
 in
 pkgs.stdenv.mkDerivation {
   name = &amp;quot;my-paper&amp;quot;;
   src = pkgs.fetchgit {
       url = &amp;quot;https://github.com/b-rodrigues/my_paper/&amp;quot;;
       branchName = &amp;quot;main&amp;quot;;
       rev = &amp;quot;715e9f007d104c23763cebaf03782b8e80cb5445&amp;quot;;
       sha256 = &amp;quot;sha256-e8Xg7nJookKoIfiJVTGoJkvCuFNTT83YZ6SK3GT2T8g=&amp;quot;;
     };
   buildInputs = [  rpkgs tex system_packages  ];
   buildPhase =
     &amp;#39;&amp;#39;
     # Deno needs to add stuff to $HOME/.cache
     # so we give it a home to do this
     mkdir home
     export HOME=$PWD/home
     quarto add --no-prompt $src
     quarto render $PWD/template.qmd --to jss-pdf
     &amp;#39;&amp;#39;;
   installPhase =
     &amp;#39;&amp;#39;
     mkdir -p $out
     cp template.pdf $out/
     &amp;#39;&amp;#39;;
 }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So we changed the second part of the file, we’re not building a shell anymore
using &lt;code&gt;mkShell&lt;/code&gt;, but a &lt;em&gt;derivation&lt;/em&gt;. &lt;em&gt;Derivation&lt;/em&gt; is Nix jargon for package, or
software. So what is our derivation? First, we clone the repo we forked just
before (I forked the repository and called it &lt;code&gt;my_paper&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pkgs.stdenv.mkDerivation {
  name = &amp;quot;my-paper&amp;quot;;
  src = pkgs.fetchgit {
      url = &amp;quot;https://github.com/b-rodrigues/my_paper/&amp;quot;;
      branchName = &amp;quot;main&amp;quot;;
      rev = &amp;quot;715e9f007d104c23763cebaf03782b8e80cb5445&amp;quot;;
      sha256 = &amp;quot;sha256-e8Xg7nJookKoIfiJVTGoJkvCuFNTT83YZ6SK3GT2T8g=&amp;quot;;
    };&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This repo contains our quarto template, and because we’re using a specific
commit, we will always use exactly this release of the template for our
document. This is in contrast to before where we used &lt;code&gt;quarto add quarto-journals/jss&lt;/code&gt; to install the template. Doing this interactively makes our
project not reproducible because if we compile our Quarto doc today, we would be
using the template as it is today, but if we compile the document in 6 months,
then we would be using the template as it would be in 6 months (I should say
that it is possible to install specific releases of Quarto templates using
following notation: &lt;code&gt;quarto add quarto-journals/jss@v0.9.2&lt;/code&gt; so this problem can
be mitigated).&lt;/p&gt;
&lt;p&gt;The next part of the file contains following lines:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;buildInputs = [  rpkgs tex system_packages  ];
buildPhase =
  &amp;#39;&amp;#39;
  # Deno needs to add stuff to $HOME/.cache
  # so we give it a home to do this
  mkdir home
  export HOME=$PWD/home
  quarto add --no-prompt $src
  quarto render $PWD/template.qmd --to jss-pdf
  &amp;#39;&amp;#39;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;buildInputs&lt;/code&gt; are the same as before. What’s new is the &lt;code&gt;buildPhase&lt;/code&gt;.
This is actually the part in which the document gets compiled. The first
step is to create a &lt;code&gt;home&lt;/code&gt; directory. This is because Quarto needs to save
the template we want to use in &lt;code&gt;/home/.cache/deno&lt;/code&gt;. If you’re using
&lt;code&gt;quarto&lt;/code&gt; interactively, that’s not an issue, since your home directory
will be used. But with Nix, things are different, so we need to create
an empty directory and specify this as the home. This is what these
two lines do:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir home
export HOME=$PWD/home&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(&lt;code&gt;$PWD&lt;/code&gt; —Print Working Directory— is a shell variable referring to the current
working directory.)&lt;/p&gt;
&lt;p&gt;Now, we need to install the template that we cloned from Github. For this we can
use &lt;code&gt;quarto add&lt;/code&gt; just as before, but instead of installing it directly from
Github, we install it from the repository that we cloned. We also add the
&lt;code&gt;--no-prompt&lt;/code&gt; flag so that the template gets installed without asking us for
confirmation. This is similar to how when building a Docker image, we don’t want
any interactive prompt to show up, or else the process will get stuck. &lt;code&gt;$src&lt;/code&gt;
refers to the path of our downloaded Github repository. Finally we can compile
the document:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;quarto render $PWD/template.qmd --to jss-pdf&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will compile the &lt;code&gt;template.qmd&lt;/code&gt; (our finished paper). Finally, there’s the
&lt;code&gt;installPhase&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;installPhase =
  &amp;#39;&amp;#39;
  mkdir -p $out
  cp template.pdf $out/
  &amp;#39;&amp;#39;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;$out&lt;/code&gt; is a shell variable defined inside the build environment and refers to
the path, so we can use it to create a directory that will contain our output
(the compiled PDF file). So we use &lt;code&gt;mkdir -p&lt;/code&gt; to recursively create all the
directory structure, and then copy the compiled document to &lt;code&gt;$out/&lt;/code&gt;. We can now
build our document by running &lt;code&gt;nix_build()&lt;/code&gt;. Now, you may be confused by the
fact that you won’t see the PDF in your working directory. But remember that
software built by Nix will always be stored in the Nix store, so our PDF is also
in the store, since this is what we built. To find it, run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;readlink result&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which will show the path to the PDF. You could use this to open the
PDF in your PDF viewer application (on Linux at least):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;xdg-open $(readlink result)/template.pdf&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This vignette showed two approaches, both have their merits: the first approach
that is more interactive is useful while writing the document. You get access to
a shell and can work on the document and compile it quickly. The second approach
is more useful once the document is ready and you want to have a way of quickly
rebuilding it for reproducibility purposes. This approach should also be quite
useful in a CI/CD environment.&lt;/p&gt;
&lt;p&gt;
Hope you enjoyed! If you found this blog post useful, you might want to follow
me on &lt;a href=&#34;https://fosstodon.org/@brodriguesco&#34;&gt;Mastodon&lt;/a&gt; or &lt;a href=&#34;https://www.twitter.com/brodriguesco&#34;&gt;twitter&lt;/a&gt; for blog post updates and
&lt;a href=&#34;https://www.buymeacoffee.com/brodriguesco&#34;&gt;buy me an espresso&lt;/a&gt; or &lt;a href=&#34;https://www.paypal.me/brodriguesco&#34;&gt;paypal.me&lt;/a&gt;, or buy my &lt;a href=&#34;https://www.brodrigues.co/about/books/&#34;&gt;ebooks&lt;/a&gt;.
You can also watch my videos on &lt;a href=&#34;https://www.youtube.com/c/BrunoRodrigues1988/&#34;&gt;youtube&lt;/a&gt;.
So much content for you to consoom!
&lt;/p&gt;
&lt;style&gt;.bmc-button img{width: 27px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-flex !important;color:#ffffff !important;background-color:#272b30 !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 1px 9px !important;font-size: 22px !important;letter-spacing:0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:&#39;Cookie&#39;, cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#82518c !important;}&lt;/style&gt;
&lt;p&gt;
&lt;link href=&#34;https://fonts.googleapis.com/css?family=Cookie&#34; rel=&#34;stylesheet&#34;&gt;&lt;a class=&#34;bmc-button&#34; target=&#34;_blank&#34; href=&#34;https://www.buymeacoffee.com/brodriguesco&#34;&gt;&lt;img src=&#34;https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg&#34; alt=&#34;Buy me an Espresso&#34;&gt;&lt;span style=&#34;margin-left:5px&#34;&gt;Buy me an Espresso&lt;/span&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Reproducible data science with Nix, part 4 -- So long, {renv} and Docker, and thanks for all the fish</title>
      <link>https://www.brodrigues.co/blog/2023-08-12-nix_for_r_part4/</link>
      <pubDate>Sat, 12 Aug 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.brodrigues.co/blog/2023-08-12-nix_for_r_part4/</guid>
      <description>&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;p&gt;&lt;img src=&#34;https://www.brodrigues.co/img/friendship ended with docker.png&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;For this blog post, I also made a youtube video that goes over roughly the same
ideas, but the blog post is more detailed as I explain the contents of
&lt;code&gt;default.nix&lt;/code&gt; files, which I don’t do in the video. Watch the video
&lt;a href=&#34;https://www.youtube.com/watch?v=c1LhgeTTxaI&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This is the fourth post in a series of posts about Nix. &lt;em&gt;Disclaimer:&lt;/em&gt; I’m a
super beginner with Nix. So this series of blog posts is more akin to notes that
I’m taking while learning than a super detailed Nix tutorial. So if you’re a Nix
expert and read something stupid in here, that’s normal. This post is going to
focus on R (obviously) but the ideas are applicable to any programming language.&lt;/p&gt;
&lt;p&gt;If you’ve never heard of Nix, take a look at &lt;a href=&#34;https://www.brodrigues.co/blog/2023-07-13-nix_for_r_part1/&#34;&gt;part
1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In this blog post I will go over many, nitty-gritty details and explain, line by
line, what a Nix expression you can use to build an environment for your
projects contains. In practice, building such an environment allows you to
essentially replace &lt;code&gt;{renv}&lt;/code&gt;+Docker, but writing the right expressions to
achieve it is not easy. So this blog post will also go over the features of
&lt;code&gt;{rix}&lt;/code&gt;, an &lt;a href=&#34;https://b-rodrigues.github.io/rix/index.html&#34;&gt;R package&lt;/a&gt; by
&lt;a href=&#34;https://github.com/philipp-baumann&#34;&gt;Philipp Baumann&lt;/a&gt; and myself.&lt;/p&gt;
&lt;p&gt;Let me also address the click-bait title directly. Yes, the title is click-bait
and I got you. I don’t believe that &lt;code&gt;{renv}&lt;/code&gt; and Docker are going away any time
soon and you should not hesitate to invest the required time to get to know and
use these tools (I wrote &lt;a href=&#34;https://raps-with-r.dev/&#34;&gt;something by the way&lt;/a&gt;). But
I am more and more convinced that Nix is an amazing alternative that offers many
possibilities, albeit with a high entry cost. By writing &lt;code&gt;{rix}&lt;/code&gt;, we aimed at
decreasing this entry cost as much as possible. However, more documentation,
examples, etc., need to be written and more testing is required. This series of
blog posts is a first step to get the word out and get people interested in the
package and more broadly in Nix. So if you’re interested or intrigued, don’t
hesitate to get in touch!&lt;/p&gt;
&lt;p&gt;This will be a long and boring post. Unless you really want to know how all of
this works go watch the Youtube video, which is more practical instead. I needed
to write this down, as it will likely serve as documentation. I’m essentially
beta testing it with you, so if you do take the time to read, and even better,
to try out the code, please let us know how it went! Was it clear, was it
simple, was it useful? Many thanks in advance.&lt;/p&gt;
&lt;div id=&#34;part-1-starting-a-new-project-with-nix&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Part 1: starting a new project with Nix&lt;/h2&gt;
&lt;p&gt;Let’s suppose that you don’t even have R installed on your computer yet. Maybe
you bought a new computer, or changed operating system, whatever. Maybe you even
have R already, which you installed from the installer that you can download
from the R project website. It doesn’t matter, as we are going to install a
(somewhat) isolated version of R using Nix for the purposes of this blog post.
If you don’t know where to start, it’s simple: first, use the &lt;a href=&#34;https://zero-to-nix.com/start/install&#34;&gt;installer from
Determinate Systems&lt;/a&gt;. This installer will
make it easy to install Nix on Linux, macOS or Windows (with WSL2). Once you
have Nix installed, you can use it to install R and &lt;code&gt;{rix}&lt;/code&gt; to start building
reproducible development environments. To help you get started, you can run this
line here (as documented in &lt;code&gt;{rix}&lt;/code&gt;’s Readme), which will &lt;em&gt;drop you into a Nix
shell&lt;/em&gt; with R and &lt;code&gt;{rix}&lt;/code&gt; available. Run the line inside a terminal (if you’re
running Windows, run this in a Linux distribution that you installed for WSL2):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nix-shell --expr &amp;quot;$(curl -sl https://raw.githubusercontent.com/b-rodrigues/rix/master/inst/extdata/default.nix)&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will take a bit to run, and then you will be inside an R session. This
environment is not suited for development, but is only provided as an easy way
for you to start using &lt;code&gt;{rix}&lt;/code&gt;. Using &lt;code&gt;{rix}&lt;/code&gt;, you can now use it to create a
more complex environment suited for a project that you would like to start.
Let’s start by loading &lt;code&gt;{rix}&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(rix)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you can run the following command to create an environment with the latest
version of R and some packages (change the R version and list of packages to
suit your needs):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;path_default_nix &amp;lt;- &amp;quot;path/to/my/project&amp;quot;

rix(r_ver = &amp;quot;current&amp;quot;,
    r_pkgs = c(&amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;),
    other_pkgs = NULL,
    git_pkgs = list(package_name = &amp;quot;housing&amp;quot;,
                    repo_url = &amp;quot;https://github.com/rap4all/housing&amp;quot;,
                    branch_name = &amp;quot;fusen&amp;quot;,
                    commit = &amp;quot;1c860959310b80e67c41f7bbdc3e84cef00df18e&amp;quot;),
    ide = &amp;quot;rstudio&amp;quot;,
    project_path = path_default_nix,
    overwrite = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Running the code above will create the following &lt;code&gt;default.nix&lt;/code&gt; file in
&lt;code&gt;path/to/my/project&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# This file was generated by the {rix} R package on Sat Aug 12 22:18:55 2023
# with following call:
# &amp;gt;rix(r_ver = &amp;quot;cf73a86c35a84de0e2f3ba494327cf6fb51c0dfd&amp;quot;,
#  &amp;gt; r_pkgs = c(&amp;quot;dplyr&amp;quot;,
#  &amp;gt; &amp;quot;ggplot2&amp;quot;),
#  &amp;gt; other_pkgs = NULL,
#  &amp;gt; git_pkgs = list(package_name = &amp;quot;housing&amp;quot;,
#  &amp;gt; repo_url = &amp;quot;https://github.com/rap4all/housing&amp;quot;,
#  &amp;gt; branch_name = &amp;quot;fusen&amp;quot;,
#  &amp;gt; commit = &amp;quot;1c860959310b80e67c41f7bbdc3e84cef00df18e&amp;quot;),
#  &amp;gt; ide = &amp;quot;rstudio&amp;quot;,
#  &amp;gt; project_path = path_default_nix,
#  &amp;gt; overwrite = TRUE)
# It uses nixpkgs&amp;#39; revision cf73a86c35a84de0e2f3ba494327cf6fb51c0dfd for reproducibility purposes
# which will install R as it was as of nixpkgs revision: cf73a86c35a84de0e2f3ba494327cf6fb51c0dfd
# Report any issues to https://github.com/b-rodrigues/rix
{ pkgs ? import (fetchTarball &amp;quot;https://github.com/NixOS/nixpkgs/archive/cf73a86c35a84de0e2f3ba494327cf6fb51c0dfd.tar.gz&amp;quot;) {} }:

with pkgs;

let
  my-r = rWrapper.override {
    packages = with rPackages; [
        dplyr
        ggplot2
        (buildRPackage {
          name = &amp;quot;housing&amp;quot;;
          src = fetchgit {
          url = &amp;quot;https://github.com/rap4all/housing&amp;quot;;
          branchName = &amp;quot;fusen&amp;quot;;
          rev = &amp;quot;1c860959310b80e67c41f7bbdc3e84cef00df18e&amp;quot;;
          sha256 = &amp;quot;sha256-s4KGtfKQ7hL0sfDhGb4BpBpspfefBN6hf+XlslqyEn4=&amp;quot;;
          };
          propagatedBuildInputs = [
            dplyr
            ggplot2
            janitor
            purrr
            readxl
            rlang
            rvest
            stringr
            tidyr
            ];
          })
        ];
    };
  my-rstudio = rstudioWrapper.override {
    packages = with rPackages; [
        dplyr
        ggplot2
        (buildRPackage {
          name = &amp;quot;housing&amp;quot;;
          src = fetchgit {
          url = &amp;quot;https://github.com/rap4all/housing&amp;quot;;
          branchName = &amp;quot;fusen&amp;quot;;
          rev = &amp;quot;1c860959310b80e67c41f7bbdc3e84cef00df18e&amp;quot;;
          sha256 = &amp;quot;sha256-s4KGtfKQ7hL0sfDhGb4BpBpspfefBN6hf+XlslqyEn4=&amp;quot;;
          };
          propagatedBuildInputs = [
            dplyr
            ggplot2
            janitor
            purrr
            readxl
            rlang
            rvest
            stringr
            tidyr
            ];
          })
        ];
    };
in
 mkShell {
   LOCALE_ARCHIVE = &amp;quot;${glibcLocales}/lib/locale/locale-archive&amp;quot;;
     buildInputs = [
        my-r
        my-rstudio
      ];
 }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s go through it. The first thing you will notice is that this file is
written in a language that you might not know: this language is called Nix as
well! So &lt;em&gt;Nix&lt;/em&gt; can both refer to the package manager, but also to the
programming language. The Nix programming language was designed for creating and
composing &lt;em&gt;derivations&lt;/em&gt;. A derivation is Nix jargon for a package (not
necessarily an R package; any piece of software that you can install through Nix
is a package). To know more about the language itself, you can
&lt;a href=&#34;https://nixos.org/manual/nix/stable/language/index.html&#34;&gt;RTFM&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let’s go back to our &lt;code&gt;default.nix&lt;/code&gt; file. The first lines state the revision of
&lt;code&gt;nixpkgs&lt;/code&gt; used that is being used in this expression, as well as which version
of R gets installed through it. &lt;code&gt;nixpkgs&lt;/code&gt; is Nix’s repository which contains all
the software that we will be installing. This is important to understand: since
all the expressions that build all the software available through &lt;code&gt;nixpkgs&lt;/code&gt; are
versioned on &lt;a href=&#34;https://github.com/NixOS/nixpkgs/tree/master/pkgs&#34;&gt;Github&lt;/a&gt;, it is
possible to choose a particular commit, or revision, and use that particular
release of &lt;code&gt;nixpkgs&lt;/code&gt;. So by judiciously choosing the right commit, it’s possible
to install any version of R (well any version until 3.0.2). &lt;code&gt;{rix}&lt;/code&gt; takes care
of this for you: state the version of R that is needed, and the right revision
will be returned (the list of R versions and revisions can be found
&lt;a href=&#34;https://lazamar.co.uk/nix-versions/?channel=nixpkgs-unstable&amp;amp;package=r&#34;&gt;here&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;The call that was used to generate the &lt;code&gt;default.nix&lt;/code&gt; file is also saved, but if
you look at the argument &lt;code&gt;r_ver&lt;/code&gt;, the &lt;code&gt;nixpkgs&lt;/code&gt; revision is specified instead of
&lt;code&gt;&#34;current&#34;&lt;/code&gt;. This is because if you re-run this call but keep
&lt;code&gt;r_ver = &#34;current&#34;&lt;/code&gt;, another, more recent &lt;code&gt;nixpkgs&lt;/code&gt; revision will get used
instead, which will break reproducibility. To avoid this, the expression gets
changed, so if you re-run it, you’re sure to find the exact same environment.&lt;/p&gt;
&lt;p&gt;Then comes this line:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ pkgs ? import (fetchTarball &amp;quot;https://github.com/NixOS/nixpkgs/archive/cf73a86c35a84de0e2f3ba494327cf6fb51c0dfd.tar.gz&amp;quot;) {} }:&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This actually defines a function with argument &lt;code&gt;pkgs&lt;/code&gt; that is optional (hence
the &lt;code&gt;?&lt;/code&gt;). All that follows, &lt;code&gt;import (fetchTarball ... ) {}&lt;/code&gt; is the default value
for &lt;code&gt;pkgs&lt;/code&gt; if no argument is provided when you run this (which will always be
the case). So here, if I call this function without providing any &lt;code&gt;pkgs&lt;/code&gt;
argument, the release of &lt;code&gt;nixpkgs&lt;/code&gt; at that commit will be used. Then comes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;with pkgs;

let
  my-pkgs = rWrapper.override {
    packages = with rPackages; [
      dplyr
      ggplot2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;with pkgs&lt;/code&gt; statement makes all the imported packages available in the scope
of the function. So I can write &lt;code&gt;quarto&lt;/code&gt; if I want to install Quarto (the
program that compiles &lt;code&gt;.qmd&lt;/code&gt; files, not the &lt;code&gt;{quarto}&lt;/code&gt; R package that provides
bindings to it) instead of &lt;code&gt;nixpkgs.quarto&lt;/code&gt;. Actually, R also has &lt;code&gt;with()&lt;/code&gt;, so
you can write this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;with(mtcars, plot(mpg ~ hp))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://www.brodrigues.co/blog/2023-08-12-nix_for_r_part4_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;instead of this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(mtcars$mpg ~ mtcars$hp)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then follows a &lt;code&gt;let ... in&lt;/code&gt;. This is how a variable gets defined locally, for
example, this is a valid Nix statement:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let x = 1; y = 2; in x + y&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which will obviously return &lt;code&gt;3&lt;/code&gt;. So here we are defining a series of packages
that will ultimately be available in our environment. These packages are named
&lt;code&gt;my-pkgs&lt;/code&gt; and are a list of R packages. You can see that I use a wrapper called
&lt;code&gt;rWrapper&lt;/code&gt; which changes certain options to make R installed through Nix work
well. This wrapper has a &lt;code&gt;packages&lt;/code&gt; attribute which I override using its
&lt;code&gt;.override&lt;/code&gt; method, and then I redefine &lt;code&gt;packages&lt;/code&gt; as a list of R packages. Just
like before, I use &lt;code&gt;with rPackages&lt;/code&gt; before listing them, which allows me to
write &lt;code&gt;dplyr&lt;/code&gt; instead of &lt;code&gt;rPackages.dplyr&lt;/code&gt; to refer to the &lt;code&gt;{dplyr}&lt;/code&gt; packages. R
packages that have a &lt;code&gt;.&lt;/code&gt; character in their name must be written using &lt;code&gt;_&lt;/code&gt;, so
if you need &lt;code&gt;{data.table}&lt;/code&gt; you’ll need to write &lt;code&gt;data_table&lt;/code&gt; (but &lt;code&gt;{rix}&lt;/code&gt; does
this for you as well, so don’t worry). Then follows the list of R packages
available through &lt;code&gt;nixpkgs&lt;/code&gt; (which is the entirety of CRAN:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;packages = with rPackages; [
          dplyr
          ggplot2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each time you need to add a package, add it here, and rebuild your environment,
do not run &lt;code&gt;install.packages(blabla)&lt;/code&gt; to install the &lt;code&gt;{blabla}&lt;/code&gt; package, because
it’s likely not going to work anyways, and it’s not reproducible. Your projects
need to be entirely defined as code. This also means that packages that have
helper functions that install something, for example
&lt;code&gt;tinytex::install_tinytex()&lt;/code&gt;, cannot be used anymore. Instead, you will need to
install &lt;code&gt;texlive&lt;/code&gt; (by putting it in &lt;code&gt;other_pkgs&lt;/code&gt;) and rebuild the expression. We
plan to write vignettes documenting all these use-cases. For example, my blog is
still built using Hugo (and will likely stay like this forever). I’m using a
very old version of Hugo to generate it (I don’t want to upgrade and have to
deal with potential issues), so I install the right version I need using Nix,
instead of using &lt;code&gt;blogdown::install_hugo()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Then comes the expression that installs a package from Github:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(buildRPackage {
  name = &amp;quot;housing&amp;quot;;
  src = fetchgit {
  url = &amp;quot;https://github.com/rap4all/housing&amp;quot;;
  branchName = &amp;quot;fusen&amp;quot;;
  rev = &amp;quot;1c860959310b80e67c41f7bbdc3e84cef00df18e&amp;quot;;
  sha256 = &amp;quot;sha256-s4KGtfKQ7hL0sfDhGb4BpBpspfefBN6hf+XlslqyEn4=&amp;quot;;
  };
  propagatedBuildInputs = [
    dplyr
    ggplot2
    janitor
    purrr
    readxl
    rlang
    rvest
    stringr
    tidyr
    ];
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see it’s quite a mouthful, but it was generated from this R code
only:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;git_pkgs = list(package_name = &amp;quot;housing&amp;quot;,
                repo_url = &amp;quot;https://github.com/rap4all/housing&amp;quot;,
                branch_name = &amp;quot;fusen&amp;quot;,
                commit = &amp;quot;1c860959310b80e67c41f7bbdc3e84cef00df18e&amp;quot;),&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you want to install more than one package, you can also provide a list of
lists, for example:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;git_pkgs = list(
  list(package_name = &amp;quot;housing&amp;quot;,
       repo_url = &amp;quot;https://github.com/rap4all/housing/&amp;quot;,
       branch_name = &amp;quot;fusen&amp;quot;,
       commit = &amp;quot;1c860959310b80e67c41f7bbdc3e84cef00df18e&amp;quot;),
  list(package_name = &amp;quot;fusen&amp;quot;,
       repo_url = &amp;quot;https://github.com/ThinkR-open/fusen&amp;quot;,
       branch_name = &amp;quot;main&amp;quot;,
       commit = &amp;quot;d617172447d2947efb20ad6a4463742b8a5d79dc&amp;quot;)
),
...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and the right expressions will be generated. There’s actually a lot going on
here, so let me explain. The first thing is the &lt;code&gt;sha256&lt;/code&gt; field. This field
contains a hash that gets generated by Nix, and that must be provided by the
user. But users rarely, if ever, know this value, so instead what they do is
they try to build the expression without providing it. An error message like
this one gets returned:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: hash mismatch in fixed-output derivation &amp;#39;/nix/store/449zx4p6x0yijym14q3jslg55kihzw66-housing-1c86095.drv&amp;#39;:
         specified: sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
            got:    sha256-s4KGtfKQ7hL0sfDhGb4BpBpspfefBN6hf+XlslqyEn4=&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;sha256&lt;/code&gt; can now get copy-and-pasted into the expression. This approach is
called “Trust On First Use”, or TOFU for short. Because this is quite annoying,
&lt;code&gt;{rix}&lt;/code&gt; provides a “private” function, called &lt;code&gt;get_sri_hash_deps()&lt;/code&gt; that
generates this hash for you. The issue is that this hash cannot be computed
easily if you don’t have Nix installed, and since I don’t want to force users to
install Nix to use &lt;code&gt;{rix}&lt;/code&gt;, what I did is that I set up a server with Nix
installed and a &lt;code&gt;{plumber}&lt;/code&gt; api. &lt;code&gt;get_sri_hash_deps()&lt;/code&gt; makes a call to that api
and gets back the &lt;code&gt;sha256&lt;/code&gt;, and also a list of packages (more on this later).&lt;/p&gt;
&lt;p&gt;You can try making a call to the api if you have &lt;code&gt;curl&lt;/code&gt; installed on your
system:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -X GET &amp;quot;http://git2nixsha.dev:1506/hash?repo_url=https://github.com/rap4all/housing/&amp;amp;branchName=fusen&amp;amp;commit=1c860959310b80e67c41f7bbdc3e84cef00df18e&amp;quot; -H &amp;quot;accept: */*&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is what you will get back:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;sri_hash&amp;quot; : [&amp;quot;sha256-s4KGtfKQ7hL0sfDhGb4BpBpspfefBN6hf+XlslqyEn4=&amp;quot;],
  &amp;quot;deps&amp;quot;     : [&amp;quot;dplyr ggplot2 janitor purrr readxl rlang rvest stringr tidyr&amp;quot;]
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The reason computing &lt;code&gt;sri_hash&lt;/code&gt; is not easy is because it gets computed on the
folder containing the source code (after having deleted the &lt;code&gt;.git&lt;/code&gt; folder in the
case of a Github repo) after it was &lt;em&gt;serialised&lt;/em&gt;. You are certainly familiar
with serialisations such as the ZIP or TAR serialisation (in other words,
zipping a folder is “serialising” it). But these serialisation algorithms come
with certain shortcomings that I won’t discuss here, but if you’re interested
check out section &lt;em&gt;5.2. The Nix store&lt;/em&gt; from Eelco Dolstra’s Phd thesis which you
can find &lt;a href=&#34;https://archive.is/S9meY&#34;&gt;here&lt;/a&gt;. Instead, a Nix-specific serialisation
algorithm was developed, called NAR. So to compute this hash, I either had to
implement this serialisation algorithm in R, or write an api that does that for
me by using the implementation that ships with Nix. Since I’m not talented
enough to implement such an algorithm in R, I went for the api. But who knows,
maybe in the future this could be done. There are implementation of this
algorithm in other programming languages like Rust, so maybe packaging the Rust
binary could be an option.&lt;/p&gt;
&lt;p&gt;This gets then further processed by &lt;code&gt;rix()&lt;/code&gt;. The second thing that gets returned
is a list of packages. These get scraped from the &lt;code&gt;Imports&lt;/code&gt; and &lt;code&gt;LinkingTo&lt;/code&gt;
sections of the &lt;code&gt;DESCRIPTION&lt;/code&gt; file from the package and are then provided as the
&lt;code&gt;propagatedBuildInputs&lt;/code&gt; in the Nix expression. These packages are dependencies
that must be available to your package at build and run-time.&lt;/p&gt;
&lt;p&gt;You should know that as of today (&lt;code&gt;{rix}&lt;/code&gt; commit &lt;code&gt;15cadf7f&lt;/code&gt;) GitHub packages
that use the &lt;code&gt;Remotes&lt;/code&gt; field (so that have dependencies that are also on Github)
are not handled by &lt;code&gt;{rix}&lt;/code&gt;, but supporting this is planned. What &lt;code&gt;{rix}&lt;/code&gt;
supports though is installing packages from the CRAN archives, so you can
specify a version of a package and have that installed. For example:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rix(r_ver = &amp;quot;current&amp;quot;,
    r_pkgs = c(&amp;quot;dplyr@0.8.0&amp;quot;, &amp;quot;ggplot2@3.1.1&amp;quot;),
    other_pkgs = NULL,
    git_pkgs = NULL,
    ide = &amp;quot;other&amp;quot;,
    path = path_default_nix,
    overwrite = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The difference with the &lt;code&gt;default.nix&lt;/code&gt; file from before is that these packages
get downloaded off the CRAN archives, so &lt;code&gt;fetchzip()&lt;/code&gt; is used to download them
instead of &lt;code&gt;fetchgit()&lt;/code&gt; (both Nix functions). Here is what the generated Nix
code looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(buildRPackage {
  name = &amp;quot;dplyr&amp;quot;;
  src = fetchzip {
  url = &amp;quot;https://cran.r-project.org/src/contrib/Archive/dplyr/dplyr_0.8.0.tar.gz&amp;quot;;
  sha256 = &amp;quot;sha256-f30raalLd9KoZKZSxeTN71PG6BczXRIiP6g7EZeH09U=&amp;quot;;
  };
  propagatedBuildInputs = [
    assertthat
    glue
    magrittr
    pkgconfig
    R6
    Rcpp
    rlang
    tibble
    tidyselect
    BH
    plogr
    Rcpp
    ];
})
(buildRPackage {
  name = &amp;quot;ggplot2&amp;quot;;
  src = fetchzip {
  url = &amp;quot;https://cran.r-project.org/src/contrib/Archive/ggplot2/ggplot2_3.1.1.tar.gz&amp;quot;;
  sha256 = &amp;quot;sha256-0Qv/5V/XMsFBcGEFy+3IAaBJIscRMTwGong6fiP5Op0=&amp;quot;;
  };
  propagatedBuildInputs = [
    digest
    gtable
    lazyeval
    MASS
    mgcv
    plyr
    reshape2
    rlang
    scales
    tibble
    viridisLite
    withr
    ];
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here’s what this looks like:&lt;/p&gt;
&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;p&gt;&lt;img src=&#34;https://www.brodrigues.co/img/new_r_old_pkgs.png&#34; width=&#34;100%&#34;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;This feature should ideally be used sparingly. If you want to reconstruct an
environment as it was around a specific date (for example to run an old
project), use the version of R that was current at that time. This will ensure
that every package that gets installed is at a version compatible with that
version of R, which might not be the case if you need to install a very old
version of one particular package. But this feature is quite useful if you want
to install a package that is not available on CRAN anymore, but that is
archived, like
&lt;a href=&#34;https://cran.r-project.org/web/packages/ZeligChoice/index.html&#34;&gt;{ZeligChoice}&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Then a second list of packages gets defined, this time using the
&lt;code&gt;rstudioWrapper&lt;/code&gt; wrapper. This is because I specified that I wanted to use
RStudio, but RStudio is a bit peculiar. It redefines many paths and so if you
have RStudio installed in your system, it won’t be able to “see” the R installed
through Nix. So you have to install RStudio through Nix as well (this is not
necessary for VS Code nor Emacs, and likely not for other editors as well).
However, it is still necessary to provide each package, again, to the
&lt;code&gt;rstudioWrapper&lt;/code&gt;. This is because the RStudio installed through Nix is also not
able to “see” the R installed through Nix as well. But don’t worry, this does
not take twice the space, since the packages simply get symlinked.&lt;/p&gt;
&lt;p&gt;The last part of the expression uses &lt;code&gt;mkShell&lt;/code&gt; which builds a shell with the
provided &lt;code&gt;buildInputs&lt;/code&gt; (our list of packages). There is also a line to define
the location of the locale archive, which should properly configure the locale
of the shell (so language, time zone and units):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;in
 mkShell {
   LOCALE_ARCHIVE = &amp;quot;${glibcLocales}/lib/locale/locale-archive&amp;quot;;
     buildInputs = [
        my-r
        my-rstudio
      ];
 }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this file in hand, we can now build the environment and use it.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;part-2-using-your-environment&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Part 2: using your environment&lt;/h2&gt;
&lt;p&gt;So let’s suppose that you have a &lt;code&gt;default.nix&lt;/code&gt; file and you wish to build the
environment. To do so, you need to have Nix installed, and, thanks to the
contributions of &lt;a href=&#34;https://github.com/philipp-baumann&#34;&gt;Philipp Baumann&lt;/a&gt;, you can
use &lt;code&gt;rix::nix_build()&lt;/code&gt; to build the environment as well:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nix_build(project_path = path_default_nix, exec_mode = &amp;quot;blocking&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you prefer, you can use Nix directly as well; navigate to the project folder
containing the &lt;code&gt;default.nix&lt;/code&gt; file and run the command line tool &lt;code&gt;nix-build&lt;/code&gt; that
gets installed with Nix:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nix-build&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will take some time to run, depending on whether cached binary packages can
be pulled from &lt;a href=&#34;https://cache.nixos.org/&#34; class=&#34;uri&#34;&gt;https://cache.nixos.org/&lt;/a&gt; or not. Once the build process is
done, you should see a file called &lt;code&gt;result&lt;/code&gt; next to the &lt;code&gt;default.nix&lt;/code&gt; file. You
can now &lt;em&gt;drop&lt;/em&gt; into the Nix shell by typing this into your operating system’s
terminal (after you navigated to the folder containing the &lt;code&gt;default.nix&lt;/code&gt; and
&lt;code&gt;result&lt;/code&gt; files):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nix-shell&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(this time, you really have to leave your current R session! But Philipp and
myself are thinking about how we could also streamline this part as well…).&lt;/p&gt;
&lt;p&gt;The environment that you just built is not an entirely isolated environment: you
can still interact with your computer, unlike with Docker. For example, you can
still use programs that are installed on your computer. This means that you can
run your usual editor as well, but starting it from the Nix shell will make your
editor be able to “see” the R installed in that environment. You need to be
careful with this, because sometimes this can lead to surprising behavior. For
example, if you already have R installed with some packages, these packages
could interfere with your Nix environment. There are two ways of dealing with
this: you either only use Nix-based environments to work (which would be my
primary recommendation, as there can be no interference between different Nix
environments), or you call &lt;code&gt;nix-shell --pure&lt;/code&gt; instead of just &lt;code&gt;nix-shell&lt;/code&gt;. This
will ensure that only whatever is available in the environment gets used, but be
warned that Nix environments are very, very lean, so you might need to add some
tools to have something completely functional.&lt;/p&gt;
&lt;p&gt;We can take advantage of the fact that environments are not completely isolated
to use our IDEs. For example, if you use VS Code or Emacs, you can use the one
that is installed directly on your system, as explained before. As already
explained, but to drive the point home, if you’re an RStudio user, you need to
specify the &lt;code&gt;ide = &#34;rstudio&#34;&lt;/code&gt; argument to &lt;code&gt;rix()&lt;/code&gt;, because in the case of
RStudio, it needs to be installed by Nix as well (the current available RStudio
version installed by Nix is now out of date, but efforts are ongoing to update
it). This is because RStudio looks for R runtimes in very specific paths, and
these need to be patched to see Nix-provided R versions. Hence the version that
gets installed by Nix gets patched so that RStudio is able to find the correct
runtimes.&lt;/p&gt;
&lt;p&gt;Once you dropped into the shell, simply type &lt;code&gt;rstudio&lt;/code&gt; to launch RStudio in that
environment (or &lt;code&gt;code&lt;/code&gt; if you use VS Code or &lt;code&gt;other&lt;/code&gt; if you use Emacs, or any
other editor). On Linux, RStudio may fail to launch with this error message:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Could not initialize GLX
Aborted (core dumped)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;change your &lt;code&gt;default.nix&lt;/code&gt; file from this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkShell {
  LOCALE_ARCHIVE = &amp;quot;${glibcLocales}/lib/locale/locale-archive&amp;quot;;
    buildInputs = [
       my-r
       my-rstudio
     ];
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkShell {
  LOCALE_ARCHIVE = &amp;quot;${glibcLocales}/lib/locale/locale-archive&amp;quot;;
    buildInputs = [
       my-r
       my-rstudio
     ];
  shellHook = &amp;#39;&amp;#39;
    export QT_XCB_GL_INTEGRATION=none
  &amp;#39;&amp;#39;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which should solve the issue, which is related to hardware acceleration as far
as I can tell.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shellHook&lt;/code&gt;s are a nice feature which I haven’t discussed a lot yet (I did so in
part 2 of this series, to run a &lt;code&gt;{targets}&lt;/code&gt; pipeline each time I dropped into
the shell). Whatever goes into the &lt;code&gt;shellHook&lt;/code&gt; gets executed as soon as one
drops into the Nix shell. I personally have to add the
&lt;code&gt;export QT_XCB_GL_INTEGRATION=none&lt;/code&gt; line in on virtual machines and on my
desktop computer as well, but I’ve had problems in the past with my graphics
drivers, and I think it’s related. I’m planning also to add an option to &lt;code&gt;rix()&lt;/code&gt;
to add this automatically.&lt;/p&gt;
&lt;p&gt;If you need to add packages, best is to call &lt;code&gt;rix::rix()&lt;/code&gt; again, but this time,
provide the &lt;code&gt;nixpkgs&lt;/code&gt; revision as the argument to &lt;code&gt;r_ver&lt;/code&gt;. Copy and paste the
call from the generated &lt;code&gt;default.nix&lt;/code&gt; to an R console and rerun it:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rix(r_ver = &amp;quot;cf73a86c35a84de0e2f3ba494327cf6fb51c0dfd&amp;quot;,
    r_pkgs = c(&amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;tidyr&amp;quot;, &amp;quot;quarto&amp;quot;),
    other_pkgs = &amp;quot;quarto&amp;quot;,
    git_pkgs = list(package_name = &amp;quot;housing&amp;quot;,
                    repo_url = &amp;quot;https://github.com/rap4all/housing&amp;quot;,
                    branch_name = &amp;quot;fusen&amp;quot;,
                    commit = &amp;quot;1c860959310b80e67c41f7bbdc3e84cef00df18e&amp;quot;),
    ide = &amp;quot;rstudio&amp;quot;,
    path = path_default_nix,
    overwrite = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the call above I’ve added the &lt;code&gt;{tidyr}&lt;/code&gt; and &lt;code&gt;{quarto}&lt;/code&gt; packages, as well as
the &lt;code&gt;quarto&lt;/code&gt; command line utility to generate &lt;code&gt;.qmd&lt;/code&gt; files. For &lt;code&gt;r_ver&lt;/code&gt; I’m this
time using the &lt;code&gt;nixpkgs&lt;/code&gt; revision from my original &lt;code&gt;default.nix&lt;/code&gt; file. This will
ensure that my environment stays the same.&lt;/p&gt;
&lt;p&gt;So if you have read up until this point, let me first thank you, and secondly
humbly ask you to test &lt;code&gt;{rix}&lt;/code&gt;! I’m looking for testers, especially on Windows
and macOS, and would be really grateful if you could provide some feedback on
the package. To report anything, simply open issue
&lt;a href=&#34;https://github.com/b-rodrigues/rix/issues&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Thanks to Philipp for proof-reading this post.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;
Hope you enjoyed! If you found this blog post useful, you might want to follow
me on &lt;a href=&#34;https://fosstodon.org/@brodriguesco&#34;&gt;Mastodon&lt;/a&gt; or &lt;a href=&#34;https://www.twitter.com/brodriguesco&#34;&gt;twitter&lt;/a&gt; for blog post updates and
&lt;a href=&#34;https://www.buymeacoffee.com/brodriguesco&#34;&gt;buy me an espresso&lt;/a&gt; or &lt;a href=&#34;https://www.paypal.me/brodriguesco&#34;&gt;paypal.me&lt;/a&gt;, or buy my &lt;a href=&#34;https://www.brodrigues.co/about/books/&#34;&gt;ebooks&lt;/a&gt;.
You can also watch my videos on &lt;a href=&#34;https://www.youtube.com/c/BrunoRodrigues1988/&#34;&gt;youtube&lt;/a&gt;.
So much content for you to consoom!
&lt;/p&gt;
&lt;style&gt;.bmc-button img{width: 27px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-flex !important;color:#ffffff !important;background-color:#272b30 !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 1px 9px !important;font-size: 22px !important;letter-spacing:0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:&#39;Cookie&#39;, cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#82518c !important;}&lt;/style&gt;
&lt;p&gt;
&lt;link href=&#34;https://fonts.googleapis.com/css?family=Cookie&#34; rel=&#34;stylesheet&#34;&gt;&lt;a class=&#34;bmc-button&#34; target=&#34;_blank&#34; href=&#34;https://www.buymeacoffee.com/brodriguesco&#34;&gt;&lt;img src=&#34;https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg&#34; alt=&#34;Buy me an Espresso&#34;&gt;&lt;span style=&#34;margin-left:5px&#34;&gt;Buy me an Espresso&lt;/span&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Reproducible data science with Nix, part 3 -- frictionless {plumber} api deployments with Nix</title>
      <link>https://www.brodrigues.co/blog/2023-07-30-nix_for_r_part3/</link>
      <pubDate>Sun, 30 Jul 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.brodrigues.co/blog/2023-07-30-nix_for_r_part3/</guid>
      <description>&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;p&gt;&lt;img src=&#34;https://www.brodrigues.co/img/i_use_nix_for_all_my_package_management_needs.png&#34; width=&#34;60%&#34;&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;This is the third post in a series of posts about Nix. Disclaimer: I’m a super
beginner with Nix. So this series of blog posts is more akin to notes that I’m
taking while learning than a super detailed tutorial. So if you’re a Nix expert
and read something stupid in here, that’s normal. This post is going to focus on
R (obviously) but the ideas are applicable to any programming language.&lt;/p&gt;
&lt;p&gt;This blog post is part tutorial on creating an api using the &lt;code&gt;{plumber}&lt;/code&gt; R
package, part an illustration of how Nix makes developing and deploying a
breeze.&lt;/p&gt;
&lt;div id=&#34;part-1-getting-it-to-work-locally&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Part 1: getting it to work locally&lt;/h2&gt;
&lt;p&gt;So in &lt;a href=&#34;https://www.brodrigues.co/blog/2023-07-13-nix_for_r_part1/&#34;&gt;part 1&lt;/a&gt; I
explained what Nix was and how you could use it to build reproducible
development environments. In &lt;a href=&#34;https://www.brodrigues.co/blog/2023-07-19-nix_for_r_part2/&#34;&gt;part
2&lt;/a&gt; I talked about
running a &lt;code&gt;{targets}&lt;/code&gt; pipeline in a reproducible environment set up with Nix,
and in this blog post I’ll talk about how I made an api using {plumber} and how
Nix made going from my development environment to the production environment (on
Digital Ocean) the simplest ever. Originally I wanted to focus on interactive
work using Nix, but that’ll be very likely for part 4, maybe even part 5 (yes, I
really have a lot to write about).&lt;/p&gt;
&lt;p&gt;Let me just first explain what &lt;code&gt;{plumber}&lt;/code&gt; is before continuing. I already
talked about &lt;code&gt;{plumber}&lt;/code&gt;
&lt;a href=&#34;https://www.brodrigues.co/blog/2021-06-04-own_knit_server/&#34;&gt;here&lt;/a&gt;, but in
summary, &lt;code&gt;{plumber}&lt;/code&gt; allows you to build an api. What is an api? Essentially a
service that you can call in different ways and which returns something to you.
For example, you could send a Word document to this api and get back the same
document converted in PDF. Or you could send some English text and get back a
translation. Or you could send some data and get a prediction from a machine
learning model. It doesn’t matter: what’s important is that apis completely
abstract the programming language that is being used to compute whatever should
be computed. With &lt;code&gt;{plumber}&lt;/code&gt;, you can create such services using R. This is
pretty awesome, because it means that whatever it is you can make with R, you
could build a service around it and make it available to anyone. Of course you
need a server that actually has R installed and that gets and processes the
requests it receives, and this is where the problems start. And by problems I
mean THE single biggest problem that you have to deal with whenever you develop
something on your computer, and then have to make it work somewhere else:
deployment. If you’ve had to deal with deployments you might not understand why
it’s so hard. I certainly didn’t really get it until I’ve wanted to deploy my
first Shiny app, many moons ago. And this is especially true whenever you don’t
want to use any “off the shelf” services like &lt;em&gt;shinyapps.io&lt;/em&gt;. In the &lt;a href=&#34;https://www.brodrigues.co/blog/2021-06-04-own_knit_server/&#34;&gt;blog post
I mentioned above&lt;/a&gt;,
I used Docker to deploy the api. But Docker, while an amazing tool, is also
quite heavy to deal with. Nix offers an alternative to Docker which I think you
should know and think about. Let me try to convince you.&lt;/p&gt;
&lt;p&gt;So let’s make a little &lt;code&gt;{plumber}&lt;/code&gt; api and deploy that in the cloud. For this, I’m
using Digital Ocean, but any other service that allows you to spin a virtual
machine (VM) with Ubuntu on it will do. If you don’t have a Digital Ocean
account, you can use my &lt;a href=&#34;https://m.do.co/c/b68adc727710&#34;&gt;referral link&lt;/a&gt; to get
200$ in credit for 60 days, more than enough to experiment. A VM serving a
&lt;code&gt;{plumber}&lt;/code&gt; api needs at least 1 gig of RAM, and the cheapest one with 1 gig of
ram is 6$ a month (if you spend 25$ of that credit, I’ll get 25$ too, so don’t
hesitate to experiment, you’ll be doing me a solid as well).&lt;/p&gt;
&lt;p&gt;I won’t explain what my api does, this doesn’t really matter for this blog post.
But I’ll have to explain it in a future blog post, because it’s related to a
package I’m working on, called &lt;a href=&#34;https://github.com/b-rodrigues/rix&#34;&gt;{rix}&lt;/a&gt; which
I’m writing to ease the process of building reproducible environments for R
using Nix. So for this blog post, let’s make something very simple: let’s take
the classic machine learning task of predicting survival of the passengers of
the Titanic (which was not that long ago in the news again…) and make a
service out of it.&lt;/p&gt;
&lt;p&gt;What’s going to happen is this: users will make a request to the api giving some
basic info about themselves: a simple ML model (I’ll go with logistic regression
and call it “machine learning” just to make the statisticians reading this
seethe lmao), the machine learning model is going to use this to compute a
prediction and the result will be returned to the user. Now to answer a question
that comes up often when I explain this stuff: &lt;em&gt;why not use Shiny? Users can
enter their data and get a prediction and there’s a nice UI and everything?!&lt;/em&gt;.
Well yes, but it depends on what it is you actually want to do. An api is useful
mostly in situations where you need that request to be made by another machine
and then that machine will do something else with that prediction it got back.
It could be as simple as showing it in a nice interface, or maybe the machine
that made the request will then use that prediction and insert it somewhere for
archiving for example. So think of it this way: use an api when machines need to
interact with other machines, a Shiny app for when humans need to interact with
a machine.&lt;/p&gt;
&lt;p&gt;Ok so first, because I’m using Nix, I’ll create an environment that will contain
everything I need to build this api. I’m doing that in the most simple way
possible, simply by specifying an R version and the packages I need inside a
file called &lt;code&gt;default.nix&lt;/code&gt;. Writing this file if you’re not familiar with Nix can
be daunting, so I’ve developed a package, called &lt;code&gt;{rix}&lt;/code&gt; to write these files
for you. Calling this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rix::rix(r_ver = &amp;quot;4.2.2&amp;quot;,
         r_pkgs = c(&amp;quot;plumber&amp;quot;, &amp;quot;tidymodels&amp;quot;),
         other_pkgs = NULL,
         git_pkgs = NULL,
         ide = &amp;quot;other&amp;quot;,
         path = &amp;quot;titanic_api/&amp;quot;, # you might need to create this folder
         overwrite = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;generates this file for me:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# This file was generated by the {rix} R package on Sat Jul 29 15:50:41 2023
# It uses nixpkgs&amp;#39; revision 8ad5e8132c5dcf977e308e7bf5517cc6cc0bf7d8 for reproducibility purposes
# which will install R version 4.2.2
# Report any issues to https://github.com/b-rodrigues/rix
{ pkgs ? import (fetchTarball &amp;quot;https://github.com/NixOS/nixpkgs/archive/8ad5e8132c5dcf977e308e7bf5517cc6cc0bf7d8.tar.gz&amp;quot;) {} }:

  with pkgs;

  let
  my-r = rWrapper.override {
    packages = with rPackages; [
      plumber tidymodels
    ];
  };
  in
  mkShell {
    buildInputs = [
      my-r
      ];
  }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(for posterity’s sake: this is using &lt;a href=&#34;https://github.com/b-rodrigues/rix/tree/935fb194b38adfb085a5bda9ebe5dc5bb504f2cb&#34;&gt;this version of
{rix}&lt;/a&gt;.
Also, if you want to learn more about &lt;code&gt;{rix}&lt;/code&gt; take a look at its
&lt;a href=&#34;https://b-rodrigues.github.io/rix/&#34;&gt;website&lt;/a&gt;. It’s still in very early
development, comments and PR more than welcome!)&lt;/p&gt;
&lt;p&gt;To build my api I’ll have to have &lt;code&gt;{plumber}&lt;/code&gt; installed. I also install the
&lt;code&gt;{tidymodels}&lt;/code&gt; package. I actually don’t need &lt;code&gt;{tidymodels}&lt;/code&gt; for what I’m doing
(base R can fit logistic regressions just fine), but the reason I’m installing
it is to mimic a “real-word example” as closely as possible (a project with some
dependencies).&lt;/p&gt;
&lt;p&gt;When I called &lt;code&gt;rix::rix()&lt;/code&gt; to generate the &lt;code&gt;default.nix&lt;/code&gt; file, I specified that
I wanted R version 4.2.2 (because let’s say that this is the version I need.
It’s also possible to get the current version of R by passing “current” to
&lt;code&gt;r_ver&lt;/code&gt;). You don’t see any reference to this version of R in the &lt;code&gt;default.nix&lt;/code&gt;
file, but this is the version that will get installed because it’s the version
that comes with that particular revision of the &lt;code&gt;nixpkgs&lt;/code&gt; repository:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;https://github.com/NixOS/nixpkgs/archive/8ad5e8132c5dcf977e308e7bf5517cc6cc0bf7d8.tar.gz&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This url downloads that particular revision on &lt;code&gt;nixpkgs&lt;/code&gt; containing R version
4.2.2. &lt;code&gt;{rix}&lt;/code&gt; finds the right revision for you (using &lt;a href=&#34;https://lazamar.co.uk/nix-versions/?channel=nixpkgs-unstable&amp;amp;package=r&#34;&gt;this handy
service&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;While &lt;code&gt;{rix}&lt;/code&gt; doesn’t require your system to have Nix installed, if you want to
continue you’ll have to install Nix. To install Nix, I recommend you don’t use
the official installer, even if it’s quite simple to use. Instead, the
&lt;a href=&#34;https://zero-to-nix.com/start/install&#34;&gt;Determinate Systems&lt;/a&gt; installer seems
better to me. On Windows, you will need to enable WSL2. An alternative is to run
all of this inside a Docker container (but more on this later if you’re thinking
something along the lines of &lt;em&gt;isn’t the purpose of Nix to not have to use
Docker?&lt;/em&gt; then see you in the conclusion). Once you have Nix up and running, go
inside the &lt;code&gt;titanic_api/&lt;/code&gt; folder (which contains the &lt;code&gt;default.nix&lt;/code&gt; file above)
and run the following command inside a terminal:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nix-build&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will build the environment according to the instructions in the
&lt;code&gt;default.nix&lt;/code&gt; file. Depending on what you want/need, this can take some time.
Once the environment is done building, you can “enter” into it by typing:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nix-shell&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now this is where you would use this environment to work on your api. As I
stated above, I’ll discuss interactive work using a Nix environment in a future
blog post. Leave the terminal with this Nix shell open and create an empty text
wile next to &lt;code&gt;default.nix&lt;/code&gt; and call it &lt;code&gt;titanic_api.R&lt;/code&gt; and put this in there
using any text editor of your choice:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#* Would you have survived the Titanic sinking?
#* @param sex Character. &amp;quot;male&amp;quot; or &amp;quot;female&amp;quot;
#* @param age Integer. Your age.
#* @get /prediction
function(sex, age) {

  trained_logreg &amp;lt;- readRDS(&amp;quot;trained_logreg.rds&amp;quot;)

  dataset &amp;lt;- data.frame(sex = sex, age = as.numeric(age))

  parsnip::predict.model_fit(trained_logreg,
                             new_data = dataset)

}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This script is a &lt;code&gt;{plumber}&lt;/code&gt; api. It’s a simple function that uses an already
&lt;em&gt;trained&lt;/em&gt; logistic regression (lol) by loading it into its scope using the
&lt;code&gt;readRDS()&lt;/code&gt; function. It then returns a prediction. The script that I wrote to
train the model is this one:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(parsnip)

titanic_raw &amp;lt;- read.csv(&amp;quot;https://web.stanford.edu/class/archive/cs/cs109/cs109.1166/stuff/titanic.csv&amp;quot;)

titanic &amp;lt;- titanic_raw |&amp;gt;
  subset(select = c(Survived,
                    Sex,
                    Age))

names(titanic) &amp;lt;- c(&amp;quot;survived&amp;quot;, &amp;quot;sex&amp;quot;, &amp;quot;age&amp;quot;)

titanic$survived = as.factor(titanic$survived)

logreg_spec &amp;lt;- logistic_reg() |&amp;gt;
  set_engine(&amp;quot;glm&amp;quot;)

trained_logreg &amp;lt;- logreg_spec |&amp;gt;
  fit(survived ~ ., data = titanic)

saveRDS(trained_logreg, &amp;quot;trained_logreg.rds&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you’re familiar with this Titanic prediction task, you will have noticed that
the script above is completely stupid. I only kept two variables to fit the
logistic regression. But the reason I did this is because this blog post is not
about fitting models, but about apis. So bear with me. Anyways, once you’re run
the script above to generate the file &lt;code&gt;trained_logreg.rds&lt;/code&gt; containing the
trained model, you can locally test the api using &lt;code&gt;{plumber}&lt;/code&gt;. Go back to the
terminal that is running your Nix shell, and now type &lt;code&gt;R&lt;/code&gt; to start R in that
session. You can then run your api inside that session using:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plumber::pr(&amp;quot;titanic_api.R&amp;quot;) |&amp;gt;
  plumber::pr_run(port = &amp;quot;8000&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Open your web browser and visit
&lt;a href=&#34;http://localhost:8000/__docs__/&#34;&gt;http://localhost:8000/&lt;strong&gt;docs&lt;/strong&gt;/&lt;/a&gt;
to see the Swagger interface to your api (Swagger is a nice little tool
that makes testing your apis way easier).&lt;/p&gt;
&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;p&gt;&lt;img src=&#34;https://www.brodrigues.co/img/swagger_plumber.png&#34; width=&#34;60%&#34;&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Using Swagger you can try out your api, click on (1) then on (2). You can enter
some mock data in (3) and (4) and then run the computation by clicking on
“Execute” (5). You’ll see the result in (7). (6) gives you a &lt;code&gt;curl&lt;/code&gt; command to
run exactly this example from a terminal. Congrats, your &lt;code&gt;{plumber}&lt;/code&gt; api is
running on your computer! Now we need to deploy it online and make it available to
the world.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;deploying-your-api&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Deploying your api&lt;/h2&gt;
&lt;p&gt;So if you have a Digital Ocean account log in (and if you don’t, use my
&lt;a href=&#34;https://m.do.co/c/b68adc727710&#34;&gt;referral link&lt;/a&gt; to get 200$ to test things out)
and click on the top-right corner on the “Create” button, and then select “Droplet”
(a fancy name for a VM):&lt;/p&gt;
&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;p&gt;&lt;img src=&#34;https://www.brodrigues.co/img/digital_ocean_1.png&#34; width=&#34;60%&#34;&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;In the next screen, select the region closest to you and then select Ubuntu as
the operating system, “Regular” for the CPU options, and then the 4$ (or the 6&lt;span class=&#34;math inline&#34;&gt;\(, it doesn&amp;#39;t matter at this stage) a month Droplet. We will need to upgrade it immediately after having created it in order to actually build the environment. This is because building the environment requires some more RAM than what the 6\)&lt;/span&gt; option offers, but starting from the cheapest option ensures that we
will then be able to downsize back to it, after the build process is done.&lt;/p&gt;
&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;p&gt;&lt;img src=&#34;https://www.brodrigues.co/img/digital_ocean_2.png&#34; width=&#34;60%&#34;&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Next comes how you want to authenticate to your VM. There are two options, one
using an SSH key, another using a password. If you’re already using Git, you can
use the same SSH key. Click on “New SSH Key” and paste the public key in the box
(you should find the key under &lt;code&gt;~/.ssh/id_rsa.pub&lt;/code&gt; if you’re using Linux). If
you’re not using Git and have no idea what SSH keys are, my first piece of
advice is to start using Git and then to generate an SSH key and login using it.
This is much more secure than a password. Finally, click on “Create Droplet”.
This will start building your VM. Once the Droplet is done building, you can
check out its IP address:&lt;/p&gt;
&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;p&gt;&lt;img src=&#34;https://www.brodrigues.co/img/digital_ocean_3.png&#34; width=&#34;100%&#34;&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Let’s immediately resize the Droplet to a larger size. As I said before,
this is only required to build our production environment using Nix. Once
the build is done, we can downsize again to the cheapest Droplet:&lt;/p&gt;
&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;p&gt;&lt;img src=&#34;https://www.brodrigues.co/img/digital_ocean_4.png&#34; width=&#34;100%&#34;&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Choose a Droplet with 2 gigs of RAM to be on the safe side, and also enable the
reserved IP option (this is a static IP that will never change):&lt;/p&gt;
&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;p&gt;&lt;img src=&#34;https://www.brodrigues.co/img/digital_ocean_5.png&#34; width=&#34;80%&#34;&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Finally, turn on your Droplet, it’s time to log in to it using SSH.&lt;/p&gt;
&lt;p&gt;Open a terminal on your computer and connect to your Droplet using SSH (starting
now, &lt;code&gt;user@local_computer&lt;/code&gt; refers to a terminal opened on your computer and
&lt;code&gt;root@droplet&lt;/code&gt; to an active ssh session inside your Droplet):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user@local_computer &amp;gt; ssh root@IP_ADDRESS_OF_YOUR_DROPLET&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and add a folder that will contain the project’s files:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@droplet &amp;gt; mkdir titanic_api&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Great, let’s now copy our files to the Droplet using &lt;code&gt;scp&lt;/code&gt;. Open a terminal on
your computer, and navigate to where the &lt;code&gt;default.nix&lt;/code&gt; file is. If you prefer
doing this graphically, you can use Filezilla. Run the following command to
copy the &lt;code&gt;default.nix&lt;/code&gt; file to the Droplet:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user@local_computer &amp;gt; scp default.nix root@IP_ADDRESS_OF_YOUR_DROPLET:/root/titanic_api/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now go back to the terminal that is logged into your Droplet. We now need to
install Nix. For this, follow the instructions from the &lt;a href=&#34;https://zero-to-nix.com/start/install&#34;&gt;Determinate
Systems&lt;/a&gt; installer, and run this line in
the Droplet:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@droplet &amp;gt; curl --proto &amp;#39;=https&amp;#39; --tlsv1.2 -sSf -L https://install.determinate.systems/nix | sh -s -- install&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pay attention to the final message once the installation is done:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Nix was installed successfully!
To get started using Nix, open a new shell or run `. /nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh`&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So run &lt;code&gt;. /nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh&lt;/code&gt; to start
the Nix daemon. Ok so now comes the magic of Nix. You can now build the exact
same environment that you used to build the pipeline on your computer in this
Droplet. Simply run &lt;code&gt;nix-build&lt;/code&gt; for the build process to start. I don’t really
know how to describe how easy and awesome this is. You may be thinking &lt;em&gt;well
installing R and a couple of packages is not that hard&lt;/em&gt;, but let me remind you
that we are using a Droplet that is running Ubuntu, which is likely NOT the
operating system that you are running. Maybe you are on Windows, maybe you are
on macOS, or maybe you’re running another Linux distribution. Whatever it is
you’re using, it will be different from that Droplet. Even if you’re running
Ubuntu on your computer, chances are that you’ve changed the CRAN repositories
from the default Ubuntu ones to the Posit ones, or maybe you’re using
&lt;a href=&#34;https://github.com/eddelbuettel/r2u&#34;&gt;r2u&lt;/a&gt;. Basically, the chances that you will
have the exact same environment in that Droplet than the one running on your
computer is basically 0. And if you’re already familiar with Docker, I think
that you will admit that this is much, much easier than dockerizing your
&lt;code&gt;{plumber}&lt;/code&gt; api. If you don’t agree, please shoot me an
&lt;a href=&#34;mailto:bruno@brodrigues.co&#34;&gt;email&lt;/a&gt; and tell me why, I’m honestly curious. Also,
let me stress again that if you needed to install a package like &lt;code&gt;{xlsx}&lt;/code&gt; that
requires Java to be installed, Nix would install the right version of Java for
you.&lt;/p&gt;
&lt;p&gt;Once the environment is done building, you can downsize your Droplet. Go back to
your Digital Ocean account, select that Droplet and choose “Resize Droplet”, and
go back to the 6$ a month plan.&lt;/p&gt;
&lt;p&gt;SSH back into the Droplet and copy the trained model &lt;code&gt;trained_logreg.rds&lt;/code&gt; and
the api file, &lt;code&gt;titanic_api.R&lt;/code&gt; to the Droplet using &lt;code&gt;scp&lt;/code&gt; or Filezilla. It’s time
to run the api. To do so, the obvious way would be simply to start an R session
and to execute the code to run the api. However, if something happens and the R
session dies, the api won’t restart. Instead, I’m using a CRON job and an
utility called &lt;code&gt;run-one&lt;/code&gt;. This utility, pre-installed in Ubuntu, runs one (1)
script at a time, and ensures that only one instance of said script is running.
So by putting this in a CRON job (CRON is a scheduler, so it executes a script
as often as you specify), &lt;code&gt;run-one&lt;/code&gt; will try to run the script. If it’s still
running, nothing happens, if the script is not running, it runs it.&lt;/p&gt;
&lt;p&gt;So go back to your local computer, and create a new text file, call it
&lt;code&gt;run_api.sh&lt;/code&gt; and write the following text in it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
while true
do
nix-shell /root/titanic_api/default.nix --run &amp;quot;Rscript -e &amp;#39;plumber::pr_run(plumber::pr(\&amp;quot;/root/titanic_api/titanic_api.R\&amp;quot;), host = \&amp;quot;0.0.0.0\&amp;quot;, port=80)&amp;#39;&amp;quot;
 sleep 10
done&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;then copy this to your VM using &lt;code&gt;scp&lt;/code&gt; or Filezilla, to
&lt;code&gt;/root/titanic_api/run_api.sh&lt;/code&gt;. Then SSH back into your Droplet, go to where
the script is using &lt;code&gt;cd&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@droplet &amp;gt; cd /root/titanic_api/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and make the script executable:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@droplet &amp;gt; chmod +x run_api.sh&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’re almost done. Now, let’s edit the &lt;code&gt;crontab&lt;/code&gt;, to specify that we want
this script to be executed every hour using &lt;code&gt;run-one&lt;/code&gt; (so if it’s running,
nothing happens, if it died, it gets restarted). To edit the &lt;code&gt;crontab&lt;/code&gt;,
type &lt;code&gt;crontab -e&lt;/code&gt; and select the editor you’re most comfortable with. If
you have no idea, select the first option, &lt;code&gt;nano&lt;/code&gt;. Using your keyboard
keys, navigate all the way down and type:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*/60 * * * * run-one /root/titanic_api/run_api.sh&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;save the file by typing &lt;code&gt;CTRL-X&lt;/code&gt;, and then type &lt;code&gt;Y&lt;/code&gt; when asked &lt;code&gt;Save modified buffer?&lt;/code&gt;, and then type the &lt;code&gt;ENTER&lt;/code&gt; key when prompted for &lt;code&gt;File name to write&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We are now ready to start the api. Make sure CRON restarts by running:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@droplet &amp;gt; service cron reload&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then run the script using &lt;code&gt;nohup&lt;/code&gt; followed by &lt;code&gt;run-one&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@droplet &amp;gt; nohup run-one /root/titanic_api/run_api.sh &amp;amp;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;run-one&lt;/code&gt; will now run the script and will ensure that only one instance of the
script is running (the &lt;code&gt;&amp;amp;&lt;/code&gt; character at the end means “run this in the
background” an &lt;code&gt;nohup&lt;/code&gt;, which stands for “no hang-up”, ensures the command will
continue running even when you close the terminal). If for any reason the
process dies, CRON will restart an instance of the script. We can now call our
api using this &lt;code&gt;curl&lt;/code&gt; command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user@local_computer &amp;gt; curl -X GET &amp;quot;http://IP_ADDRESS_OF_YOUR_DROPLET/prediction?sex=female&amp;amp;age=45&amp;quot; -H &amp;quot;accept: */*&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don’t have &lt;code&gt;curl&lt;/code&gt; installed, you can use &lt;a href=&#34;https://reqbin.com/curl&#34;&gt;this
webservice&lt;/a&gt;. You should see this answer:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[{
    &amp;quot;.pred_class&amp;quot;: &amp;quot;1&amp;quot;
}]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I’ll leave my Droplet running for a few days after I post this, so if you
want you can try it out run this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -X GET &amp;quot;http://142.93.164.182/prediction?sex=female&amp;amp;age=45&amp;quot; -H &amp;quot;accept: */*&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The answer is in the JSON format, and can now be ingested by some other script
which can now process it further.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;This was a long blog post. While it is part of my Nix series of blog posts, I
almost didn’t talk about it, and this is actually the neat part. Nix made
something that is usually difficult to solve trivially simple. Without Nix, the
alternative would be to bundle the api with all its dependencies and an R
interpreter using Docker or install everything by hand on the server. But the
issue with Docker is that it’s not necessarily much easier than Nix, and you
still have to make sure building the image is reproducible. So you have to make
sure to use an image that ships with the right version of R and use &lt;code&gt;{renv}&lt;/code&gt; to
restore your packages. If you have system-level dependencies that are required,
you also have to deal with those. Nix takes care of all of this for you, so that
you can focus on all the other aspects of deployment, which take the bulk of the
effort and time.&lt;/p&gt;
&lt;p&gt;In the post I mentioned that you could also run Nix inside a Docker container.
If you are already invested in Docker, Nix is still useful because you can use
base NixOS images (NixOS is a Linux distribution that uses Nix as its package
manager) or you could install Nix inside an Ubuntu image and then benefit from
the reproducibility offered by Nix. Simply add &lt;code&gt;RUN nix-build&lt;/code&gt; to your
Dockerfile, and everything you need gets installed. You can even use Nix to
build Docker images instead of writing a Dockerfile. The possibilities are
endless!&lt;/p&gt;
&lt;p&gt;Now, before you start building apis using R, you may want to read this blog post
&lt;a href=&#34;https://matthewrkaye.com/posts/2023-06-29-lessons-learned-from-running-r-in-production/lessons-learned-from-running-r-in-production.html&#34;&gt;here&lt;/a&gt;
as well. I found it quite interesting: it discusses the shortcomings of using
R to build apis like I showed you here, which I think you need to know. If you
have needs like the author of this blog post, then maybe R and &lt;code&gt;{plumber}&lt;/code&gt; is not
the right solution for you.&lt;/p&gt;
&lt;p&gt;Next time, in part 4, I’ll either finally discuss how to do interactive work
using a Nix environment, or I’ll discuss my package, &lt;code&gt;{rix}&lt;/code&gt; in more detail.
We’ll see!&lt;/p&gt;
&lt;p&gt;
Hope you enjoyed! If you found this blog post useful, you might want to follow
me on &lt;a href=&#34;https://fosstodon.org/@brodriguesco&#34;&gt;Mastodon&lt;/a&gt; or &lt;a href=&#34;https://www.twitter.com/brodriguesco&#34;&gt;twitter&lt;/a&gt; for blog post updates and
&lt;a href=&#34;https://www.buymeacoffee.com/brodriguesco&#34;&gt;buy me an espresso&lt;/a&gt; or &lt;a href=&#34;https://www.paypal.me/brodriguesco&#34;&gt;paypal.me&lt;/a&gt;, or buy my &lt;a href=&#34;https://www.brodrigues.co/about/books/&#34;&gt;ebooks&lt;/a&gt;.
You can also watch my videos on &lt;a href=&#34;https://www.youtube.com/c/BrunoRodrigues1988/&#34;&gt;youtube&lt;/a&gt;.
So much content for you to consoom!
&lt;/p&gt;
&lt;style&gt;.bmc-button img{width: 27px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-flex !important;color:#ffffff !important;background-color:#272b30 !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 1px 9px !important;font-size: 22px !important;letter-spacing:0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:&#39;Cookie&#39;, cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#82518c !important;}&lt;/style&gt;
&lt;p&gt;
&lt;link href=&#34;https://fonts.googleapis.com/css?family=Cookie&#34; rel=&#34;stylesheet&#34;&gt;&lt;a class=&#34;bmc-button&#34; target=&#34;_blank&#34; href=&#34;https://www.buymeacoffee.com/brodriguesco&#34;&gt;&lt;img src=&#34;https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg&#34; alt=&#34;Buy me an Espresso&#34;&gt;&lt;span style=&#34;margin-left:5px&#34;&gt;Buy me an Espresso&lt;/span&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Reproducible data science with Nix, part 2 -- running {targets} pipelines with Nix</title>
      <link>https://www.brodrigues.co/blog/2023-07-19-nix_for_r_part2/</link>
      <pubDate>Wed, 19 Jul 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.brodrigues.co/blog/2023-07-19-nix_for_r_part2/</guid>
      <description>&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;p&gt;&lt;img src=&#34;https://www.brodrigues.co/img/pipeline_nix.jpg&#34; width=&#34;100%&#34;&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;This is the second post in a series of posts about Nix. Disclaimer: I’m a super
beginner with Nix. So this series of blog posts is more akin to notes that I’m
taking while learning than a super detailed tutorial. So if you’re a Nix expert
and read something stupid in here, that’s normal. This post is going to focus on
R (obviously) but the ideas are applicable to any programming language.&lt;/p&gt;
&lt;p&gt;So in &lt;a href=&#34;https://www.brodrigues.co/blog/2023-07-13-nix_for_r_part1/&#34;&gt;part 1&lt;/a&gt; I
explained what Nix was and how you could use it to build reproducible
development environments. Now, let’s go into more details and actually set up
some environments and run a &lt;code&gt;{targets}&lt;/code&gt; pipeline using it.&lt;/p&gt;
&lt;p&gt;Obviously the first thing you should do is install Nix. A lot of what I’m
showing here comes from the &lt;a href=&#34;https://nix.dev/tutorials/&#34;&gt;Nix.dev&lt;/a&gt; so if you want
to install Nix, then look at the instructions
&lt;a href=&#34;https://nix.dev/tutorials/install-nix&#34;&gt;here&lt;/a&gt;. If you’re using Windows, you’ll
have to have WSL2 installed. If you don’t want to install Nix just yet, you can
also play around with a NixOS Docker image. NixOS is a Linux distribution that
uses the concepts of Nix for managing the whole operating system, and obviously
comes with the Nix package manager installed. But if you’re using Nix inside
Docker you won’t be able to work interactively with graphical applications like
RStudio, due to how Docker works (but more on working interactively with IDEs in
part 3 of this series, which I’m already drafting).&lt;/p&gt;
&lt;p&gt;Assuming you have Nix installed, you should be able to run the following command
in a terminal:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nix-shell -p sl&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will launch a Nix shell with the &lt;code&gt;sl&lt;/code&gt; package installed. Because &lt;code&gt;sl&lt;/code&gt; is
not available, it’ll get installed on the fly, and you will get “dropped” into a
Nix shell:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[nix-shell:~]$&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can now run &lt;code&gt;sl&lt;/code&gt; and marvel at what it does (I won’t spoil you). You can quit
the Nix shell by typing &lt;code&gt;exit&lt;/code&gt; and you’ll go back to your usual terminal. If you
try now to run &lt;code&gt;sl&lt;/code&gt; it won’t work (unless you installed on your daily machine).
So if you need to go back to that Nix shell and rerun &lt;code&gt;sl&lt;/code&gt;, simply rerun:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nix-shell -p sl&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This time you’ll be dropped into the Nix shell immediately and can run &lt;code&gt;sl&lt;/code&gt;.
So if you need to use R, simply run the following:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nix-shell -p R&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and you’ll be dropped in a Nix shell with R. This version of R will be different
than the one potentially already installed on your system, and it won’t have
access to any R packages that you might have installed. This is because Nix
environment are isolated from the rest of your system (well, not quite, but
again, more on this in part 3). So you’d need to add packages as well (exit the
Nix shell and run this command to add packages):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nix-shell -p R rPackages.dplyr rPackages.janitor&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can now start R in that Nix shell and load the &lt;code&gt;{dplyr}&lt;/code&gt; and &lt;code&gt;{janitor}&lt;/code&gt;
packages. You might be wondering how I knew that I needed to type
&lt;code&gt;rPackages.dplyr&lt;/code&gt; to install &lt;code&gt;{dplyr}&lt;/code&gt;. You can look for this information
&lt;a href=&#34;https://search.nixos.org/packages&#34;&gt;online&lt;/a&gt;. By the way, if a package uses the
&lt;code&gt;.&lt;/code&gt; character in its name, you should replace that &lt;code&gt;.&lt;/code&gt; character by &lt;code&gt;_&lt;/code&gt; so to
install &lt;code&gt;{data.table}&lt;/code&gt; write &lt;code&gt;rPackages.data_table&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So that’s nice and dandy, but not quite what we want. Instead, what we want is
to be able to declare what we need in terms of packages, dependencies, etc,
inside a file, and have Nix build an environment according to these
specifications which we can then use for our daily needs. To do so, we need to
write a so-called &lt;code&gt;default.nix&lt;/code&gt; file. This is what such a file looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ pkgs ? import (fetchTarball &amp;quot;https://github.com/NixOS/nixpkgs/archive/e11142026e2cef35ea52c9205703823df225c947.tar.gz&amp;quot;) {} }:

with pkgs;

let
  my-pkgs = rWrapper.override {
    packages = with rPackages; [dplyr ggplot2 R];
  };
in
mkShell {
  buildInputs = [my-pkgs];
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I wont discuss the intricate details of writing such a file just yet, because
it’ll take too much time and I’ll be repeating what you can find on the
&lt;a href=&#34;https://nix.dev/&#34;&gt;Nix.dev&lt;/a&gt; website. I’ll give some pointers though. But for
now, let’s assume that we already have such a &lt;code&gt;default.nix&lt;/code&gt; file that we defined
for our project, and see how we can use it to run a &lt;code&gt;{targets}&lt;/code&gt; pipeline. I’ll
explain how I write such files.&lt;/p&gt;
&lt;div id=&#34;running-a-targets-pipeline-using-nix&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Running a {targets} pipeline using Nix&lt;/h2&gt;
&lt;p&gt;Let’s say I have this, more complex, &lt;code&gt;default.nix&lt;/code&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ pkgs ? import (fetchTarball &amp;quot;https://github.com/NixOS/nixpkgs/archive/8ad5e8132c5dcf977e308e7bf5517cc6cc0bf7d8.tar.gz&amp;quot;) {} }:

with pkgs;

let
  my-pkgs = rWrapper.override {
    packages = with rPackages; [
      targets
      tarchetypes
      rmarkdown
    (buildRPackage {
      name = &amp;quot;housing&amp;quot;;
      src = fetchgit {
        url = &amp;quot;https://github.com/rap4all/housing/&amp;quot;;
        branchName = &amp;quot;fusen&amp;quot;;
        rev = &amp;quot;1c860959310b80e67c41f7bbdc3e84cef00df18e&amp;quot;;
        sha256 = &amp;quot;sha256-s4KGtfKQ7hL0sfDhGb4BpBpspfefBN6hf+XlslqyEn4=&amp;quot;;
      };
    propagatedBuildInputs = [
        dplyr
        ggplot2
        janitor
        purrr
        readxl
        rlang
        rvest
        stringr
        tidyr
        ];
      })
    ];
  };
in
mkShell {
  buildInputs = [my-pkgs];
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So the file above defines an environment that contains all the required packages
to run a pipeline that you can find on &lt;a href=&#34;https://github.com/b-rodrigues/nix_targets_pipeline&#34;&gt;this Github
repository&lt;/a&gt;. What’s
interesting is that I need to install a package that’s only been released on
Github, the &lt;code&gt;{housing}&lt;/code&gt; package that I wrote for the &lt;a href=&#34;https://raps-with-r.dev/packages.html&#34;&gt;purposes of my
book&lt;/a&gt;, and I can do so in that file as
well, using the &lt;code&gt;fetchgit()&lt;/code&gt; function. Nix has many such functions, called
&lt;em&gt;fetchers&lt;/em&gt; that simplify the process of downloading files from the internet, see
&lt;a href=&#34;https://ryantm.github.io/nixpkgs/builders/fetchers/&#34;&gt;here&lt;/a&gt;. This function takes
some self-explanatory inputs as arguments, and two other arguments that might
not be that self-explanatory: &lt;code&gt;rev&lt;/code&gt; and &lt;code&gt;sha256&lt;/code&gt;. &lt;code&gt;rev&lt;/code&gt; is actually the commit
on the Github repository. This commit is the one that I want to use for this
particular project. So if I keep working on this package, then building an
environment with this &lt;code&gt;default.nix&lt;/code&gt; will always pull the source code as it was
at that particular commit. &lt;code&gt;sha256&lt;/code&gt; is the hash of the downloaded repository. It
makes sure that the files weren’t tampered with. How did I obtain that? Well,
the simplest way is to set it to the empty string &lt;code&gt;&#34;&#34;&lt;/code&gt; and then try to build the
environment. This error message will pop-up:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: hash mismatch in fixed-output derivation &amp;#39;/nix/store/449zx4p6x0yijym14q3jslg55kihzw66-housing-1c86095.drv&amp;#39;:
         specified: sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
            got:    sha256-s4KGtfKQ7hL0sfDhGb4BpBpspfefBN6hf+XlslqyEn4=&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So simply copy the hash from the last line, and rebuild! Then if in the future
something happens to the files, you’ll know. Another interesting input is
&lt;code&gt;propagatedBuildInputs&lt;/code&gt;. These are simply the dependencies of the &lt;code&gt;{housing}&lt;/code&gt;
package. To find them, see the &lt;code&gt;Imports:&lt;/code&gt; section of the
&lt;a href=&#34;https://github.com/rap4all/housing/blob/fusen/DESCRIPTION&#34;&gt;DESCRIPTION&lt;/a&gt; file.
There’s also the &lt;code&gt;fetchFromGithub&lt;/code&gt; fetcher that I could have used, but unlike
&lt;code&gt;fetchgit&lt;/code&gt;, it is not possible to specify the branch name we want to use. Since
here I wanted to get the code from the branch called &lt;code&gt;fusen&lt;/code&gt;, I had to use
&lt;code&gt;fetchgit&lt;/code&gt;. The last thing I want to explain is the very first line:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ pkgs ? import (fetchTarball &amp;quot;https://github.com/NixOS/nixpkgs/archive/8ad5e8132c5dcf977e308e7bf5517cc6cc0bf7d8.tar.gz&amp;quot;) {} }:&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In particular the url. This url points to a specific release of &lt;code&gt;nixpkgs&lt;/code&gt;, that
ships the required version of R for this project, R version 4.2.2. How did I
find this release of &lt;code&gt;nixpkgs&lt;/code&gt;? There’s a handy service for that
&lt;a href=&#34;https://lazamar.co.uk/nix-versions/?channel=nixpkgs-unstable&amp;amp;package=r&#34;&gt;here&lt;/a&gt;.
So using this service, I get the right commit hash for the release that install
R version 4.2.2.&lt;/p&gt;
&lt;p&gt;Ok, but before building the environment defined by this file, let me just say
that I know what you’re thinking. Probably something along the lines of: &lt;em&gt;damn
it Bruno, this looks complicated and why should I care? Let me just use
{renv}!!&lt;/em&gt; and I’m not going to lie, writing the above file from scratch didn’t
take me long in typing, but it took me long in reading. I had to read quite a
lot (look at &lt;a href=&#34;https://www.brodrigues.co/blog/2023-07-13-nix_for_r_part1/&#34;&gt;part
1&lt;/a&gt; for some nice
references) before being comfortable enough to write it. But I’ll just say this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;continue reading, because I hope to convince you that Nix is really worth the effort&lt;/li&gt;
&lt;li&gt;I’m working on a package that will help R users generate &lt;code&gt;default.nix&lt;/code&gt; files like the one from above with minimal effort (more on this at the end of the blog post)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you’re following along, instead of typing this file, you can clone
this &lt;a href=&#34;https://github.com/b-rodrigues/nix_targets_pipeline&#34;&gt;repository&lt;/a&gt;.
This repository contains the &lt;code&gt;default.nix&lt;/code&gt; file from above, and a &lt;code&gt;{targets}&lt;/code&gt;
pipeline that I will run in that environment.&lt;/p&gt;
&lt;p&gt;Ok, so now let’s build the environment by running &lt;code&gt;nix-build&lt;/code&gt; inside a terminal
in the folder that contains this file. It should take a bit of time, because
many of the packages will need to be built from source. But they &lt;strong&gt;will&lt;/strong&gt; get
built. Then, you can drop into a Nix shell using &lt;code&gt;nix-shell&lt;/code&gt; and then type R,
which will start the R session in that environment. You can then simply run
&lt;code&gt;targets::tar_make()&lt;/code&gt;, and you’ll see the file &lt;code&gt;analyse.html&lt;/code&gt; appear, which is
the output of the &lt;code&gt;{targets}&lt;/code&gt; pipeline.&lt;/p&gt;
&lt;p&gt;Before continuing, let me just make you realize three things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;we just ran a targets pipeline with all the needed dependencies which include not only package dependencies, but the right version of R (version 4.2.2) as well, and all required system dependencies;&lt;/li&gt;
&lt;li&gt;we did so WITHOUT using any containerization tool like Docker;&lt;/li&gt;
&lt;li&gt;the whole thing is &lt;strong&gt;completely&lt;/strong&gt; reproducible; the exact same packages will forever be installed, regardless of &lt;em&gt;when&lt;/em&gt; we build this environment, because I’m using a particular release of &lt;code&gt;nixpkgs&lt;/code&gt; (8ad5e8132c5dcf977e308e7bf5517cc6cc0bf7d8) so each piece of software this release of Nix installs is going to stay constant.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And I need to stress &lt;em&gt;completely reproducible&lt;/em&gt;. Because using {renv}+Docker,
while providing a very nice solution, still has some issues. First of all, with
Docker, the underlying operating system (often Ubuntu) evolves and changes
through time. So lower level dependencies might change. And at some point in the
future, that version of Ubuntu will not be supported anymore. So it won’t be
possible to rebuild the image, because it won’t be possible to download any
software into it. So either we build our Docker image and really need to make
sure to keep it forever, or we need to port our pipeline to newer versions of
Ubuntu, without any guarantee that it’s going to work exactly the same. Also, by
defining &lt;code&gt;Dockerfile&lt;/code&gt;s that build upon &lt;code&gt;Dockerfile&lt;/code&gt;s that build upon
&lt;code&gt;Dockerfile&lt;/code&gt;s, it’s difficult to know what is actually installed in a particular
image. This situation can of course be avoided by writing &lt;code&gt;Dockerfile&lt;/code&gt;s in such
a way that it doesn’t rely on any other &lt;code&gt;Dockerfile&lt;/code&gt;, but that’s also a lot of
effort. Now don’t get me wrong: I’m not saying Docker should be canceled. I
still think that it has its place and that its perfectly fine to use it (I’ll
take a project that uses &lt;code&gt;{renv}&lt;/code&gt;+Docker any day over one that doesn’t!). But
you should be aware of alternative ways of running pipelines in a reproducible
way, and Nix is such a way.&lt;/p&gt;
&lt;p&gt;Going back to our pipeline, we could also run the pipeline with this command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nix-shell /path/to/default.nix --run &amp;quot;Rscript -e &amp;#39;setwd(\&amp;quot;/path/to\&amp;quot;);targets::tar_make()&amp;#39;&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;but it’s a bit of a mouthful. What you could do instead is running the pipeline
each time you drop into the nix shell by adding a so-called &lt;code&gt;shellHook&lt;/code&gt;. For
this, we need to change the &lt;code&gt;default.nix&lt;/code&gt; file again. Add these lines in the
&lt;code&gt;mkShell&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
mkShell {
  buildInputs = [my-pkgs];
  shellHook = &amp;#39;&amp;#39;
     Rscript -e &amp;quot;targets::tar_make()&amp;quot;
  &amp;#39;&amp;#39;;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, each time you drop into the Nix shell in the folder containing that
&lt;code&gt;default.nix&lt;/code&gt; file, &lt;code&gt;targets::tar_make()&lt;/code&gt; get automatically executed. You can
then inspect the results.&lt;/p&gt;
&lt;p&gt;In the next blog post, I’ll show how we can use that environment with IDEs like
RStudio, VS Code and Emacs to work interactively. But first, let me quickly talk
about a package I’ve been working on to ease the process of writing
&lt;code&gt;default.nix&lt;/code&gt; files.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;rix-reproducible-environments-with-nix&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Rix: Reproducible Environments with Nix&lt;/h2&gt;
&lt;p&gt;I wrote a very early, experimental package called &lt;code&gt;{rix}&lt;/code&gt; which will help write
these &lt;code&gt;default.nix&lt;/code&gt; files for us. &lt;code&gt;{rix}&lt;/code&gt; is an R package that hopefully will
make R users want to try out Nix for their development purposes. It aims to
mimic the workflow of &lt;code&gt;{renv}&lt;/code&gt;, or to be more exact, the workflow of what Python
users do when starting a new project. Usually what they do is create a
completely fresh environment using &lt;code&gt;pyenv&lt;/code&gt; (or another similar tool). Using
&lt;code&gt;pyenv&lt;/code&gt;, Python developers can install a per project version of Python and
Python packages, but unlike Nix, won’t install system-level dependencies as
well.&lt;/p&gt;
&lt;p&gt;If you want to install &lt;code&gt;{rix}&lt;/code&gt;, run the following line in an R session:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::install_github(&amp;quot;b-rodrigues/rix&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can then using the &lt;code&gt;rix()&lt;/code&gt; function to create a &lt;code&gt;default.nix&lt;/code&gt; file like so:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rix::rix(r_ver = &amp;quot;current&amp;quot;,
         pkgs = c(&amp;quot;dplyr&amp;quot;, &amp;quot;janitor&amp;quot;),
         ide = &amp;quot;rstudio&amp;quot;,
         path = &amp;quot;.&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will create a &lt;code&gt;default.nix&lt;/code&gt; file that Nix can use to build an environment
that includes the current versions of R, &lt;code&gt;{dplyr}&lt;/code&gt; and &lt;code&gt;{janitor}&lt;/code&gt;, and RStudio
as well. Yes you read that right: you need to have a per-project RStudio
installation. The reason is that RStudio modifies environment variables and so
your “locally” installed RStudio would not find the R version installed with
Nix. This is not the case with other IDEs like VS Code or Emacs. If you
want to have an environment with another version of R, simply run:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rix::rix(r_ver = &amp;quot;4.2.1&amp;quot;,
         pkgs = c(&amp;quot;dplyr&amp;quot;, &amp;quot;janitor&amp;quot;),
         ide = &amp;quot;rstudio&amp;quot;,
         path = &amp;quot;.&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and you’ll get an environment with R version 4.2.1. To see which versions are
available, you can run &lt;code&gt;rix::available_r()&lt;/code&gt;. Learn more about &lt;code&gt;{rix}&lt;/code&gt; on its
&lt;a href=&#34;https://b-rodrigues.github.io/rix/&#34;&gt;website&lt;/a&gt;. It’s in very early stages, and
doesn’t handle packages that have only been released on Github, yet. And the
interface might change. I’m thinking of making it possible to list the packages
in a yaml file and then have &lt;code&gt;rix()&lt;/code&gt; generate the &lt;code&gt;default.nix&lt;/code&gt; file from the
yaml file. This might be cleaner. There is already something like this called
&lt;a href=&#34;https://github.com/luispedro/nixml/tree/main&#34;&gt;Nixml&lt;/a&gt;, so maybe I don’t even
need to rewrite anything!&lt;/p&gt;
&lt;p&gt;But I’ll discuss this is more detail next time, where I’ll explain how you can
use development environments built with Nix using an IDE.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;references&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The great &lt;a href=&#34;https://nix.dev/tutorials/install-nix&#34;&gt;Nix.dev&lt;/a&gt; tutorials.&lt;/li&gt;
&lt;li&gt;This &lt;a href=&#34;https://rgoswami.me/posts/rethinking-r-nix/&#34;&gt;blog post: Statistical Rethinking and Nix&lt;/a&gt; I referenced in part 1 as well, it helped me install my &lt;code&gt;{housing}&lt;/code&gt; package from Github.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/luispedro/nixml/tree/main&#34;&gt;Nixml&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
Hope you enjoyed! If you found this blog post useful, you might want to follow
me on &lt;a href=&#34;https://fosstodon.org/@brodriguesco&#34;&gt;Mastodon&lt;/a&gt; or &lt;a href=&#34;https://www.twitter.com/brodriguesco&#34;&gt;twitter&lt;/a&gt; for blog post updates and
&lt;a href=&#34;https://www.buymeacoffee.com/brodriguesco&#34;&gt;buy me an espresso&lt;/a&gt; or &lt;a href=&#34;https://www.paypal.me/brodriguesco&#34;&gt;paypal.me&lt;/a&gt;, or buy my &lt;a href=&#34;https://www.brodrigues.co/about/books/&#34;&gt;ebooks&lt;/a&gt;.
You can also watch my videos on &lt;a href=&#34;https://www.youtube.com/c/BrunoRodrigues1988/&#34;&gt;youtube&lt;/a&gt;.
So much content for you to consoom!
&lt;/p&gt;
&lt;style&gt;.bmc-button img{width: 27px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-flex !important;color:#ffffff !important;background-color:#272b30 !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 1px 9px !important;font-size: 22px !important;letter-spacing:0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:&#39;Cookie&#39;, cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#82518c !important;}&lt;/style&gt;
&lt;p&gt;
&lt;link href=&#34;https://fonts.googleapis.com/css?family=Cookie&#34; rel=&#34;stylesheet&#34;&gt;&lt;a class=&#34;bmc-button&#34; target=&#34;_blank&#34; href=&#34;https://www.buymeacoffee.com/brodriguesco&#34;&gt;&lt;img src=&#34;https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg&#34; alt=&#34;Buy me an Espresso&#34;&gt;&lt;span style=&#34;margin-left:5px&#34;&gt;Buy me an Espresso&lt;/span&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Reproducible data science with Nix, part 1 -- what is Nix</title>
      <link>https://www.brodrigues.co/blog/2023-07-13-nix_for_r_part1/</link>
      <pubDate>Thu, 13 Jul 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.brodrigues.co/blog/2023-07-13-nix_for_r_part1/</guid>
      <description>&lt;div style=&#34;text-align:center;&#34;&gt;
&lt;p&gt;&lt;img src=&#34;https://www.brodrigues.co/img/nix.jpg&#34; width=&#34;100%&#34;&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;This is the first of a (hopefully) series of posts about Nix. Disclaimer: I’m a
super beginner with Nix. So this series of blog posts is more akin to notes that
I’m taking while learning than a super detailed tutorial. So if you’re a Nix
expert and read something stupid in here, that’s normal. This post is going to
focus on R (obviously) but the ideas are applicable to any programming language.&lt;/p&gt;
&lt;p&gt;To ensure that a project is reproducible you need to deal with at least four
things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Make sure that the required/correct version of R (or any other language) is installed;&lt;/li&gt;
&lt;li&gt;Make sure that the required versions of packages are installed;&lt;/li&gt;
&lt;li&gt;Make sure that system dependencies are installed (for example, you’d need a working Java installation to install the &lt;code&gt;{rJava}&lt;/code&gt; R package on Linux);&lt;/li&gt;
&lt;li&gt;Make sure that you can install all of this for the hardware you have on hand.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For the three first bullet points, the consensus seems to be a mixture of Docker
to deal with system dependencies, &lt;code&gt;{renv}&lt;/code&gt; for the packages (or &lt;code&gt;{groundhog}&lt;/code&gt;,
or a fixed CRAN snapshot like those &lt;a href=&#34;https://packagemanager.posit.co/__docs__/user/get-repo-url/#ui-frozen-urls&#34;&gt;Posit
provides&lt;/a&gt;)
and the &lt;a href=&#34;https://github.com/r-lib/rig&#34;&gt;R installation manager&lt;/a&gt; to install the
correct version of R (unless you use a Docker image as base that already ships
the required version by default). As for the last point, the only way out is to
be able to compile the software for the target architecture. There’s a lot of
moving pieces, and knowledge that you need to know and I even wrote a whole 522
pages &lt;a href=&#34;https://raps-with-r.dev/&#34;&gt;book about all of this&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But it turns out that this is not the only solution. Docker + &lt;code&gt;{renv}&lt;/code&gt; (or some
other way to deal with packages) is likely the most popular way to ensure
reproducibility of your projects, but there are other tools to achieve this. One
such tool is called Nix.&lt;/p&gt;
&lt;p&gt;Nix is a package manager for Linux distributions, macOS and apparently it even
works on Windows if you enable WSL2. What’s a package manager? If you’re not a
Linux user, you may not be aware. Let me explain it this way: in R, if you want
to install a package to provide some functionality not included with a vanilla
installation of R, you’d run this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;install.packages(&amp;quot;dplyr&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It turns out that Linux distributions, like Ubuntu for example, work in a
similar way, but for software that you’d usually install using an installer (at
least on Windows). For example you could install Firefox on Ubuntu using:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install firefox&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(there’s also graphical interfaces that make this process “more user-friendly”).
In Linux jargon, &lt;code&gt;packages&lt;/code&gt; are simply what normies call software (or I guess
it’s all “apps” these days). These packages get downloaded from so-called
repositories (think of CRAN, the repository of R packages) but for any type of
software that you might need to make your computer work: web browsers, office
suites, multimedia software and so on.&lt;/p&gt;
&lt;p&gt;So Nix is just another package manager that you can use to install software.&lt;/p&gt;
&lt;p&gt;But what interests us is not using Nix to install Firefox, but instead to
install R and the R packages that we require for our analysis (or any other
programming language that we need). But why use Nix instead of the usual ways to
install software on our operating systems?&lt;/p&gt;
&lt;p&gt;The first thing that you should know is that Nix’s repository, &lt;code&gt;nixpkgs&lt;/code&gt;, is
huge. Humongously huge. As I’m writing these lines, &lt;a href=&#34;https://search.nixos.org/packages&#34;&gt;there’s more than 80’000
pieces of software available&lt;/a&gt;, and the
&lt;em&gt;entirety of CRAN&lt;/em&gt; is also available through &lt;code&gt;nixpkgs&lt;/code&gt;. So instead of installing
R as you usually do and then use &lt;code&gt;install.packages()&lt;/code&gt; to install packages, you
could use Nix to handle everything. But still, why use Nix at all?&lt;/p&gt;
&lt;p&gt;Nix has an interesting feature: using Nix, it is possible to install software in
(relatively) isolated environments. So using Nix, you can install as many
versions of R and R packages that you need. Suppose that you start working on a
new project. As you start the project, with Nix, you would install a
project-specific version of R and R packages that you would only use for that
particular project. If you switch projects, you’d switch versions of R and R
packages. If you are familiar with &lt;code&gt;{renv}&lt;/code&gt;, you should see that this is exactly
the same thing: the difference is that not only will you have a project-specific
library of R packages, you will also have a project-specific R version. So if
you start a project now, you’d have R version 4.2.3 installed (the latest
version available in &lt;code&gt;nixpkgs&lt;/code&gt; but not the latest version available, more on
this later), with the accompagnying versions of R packages, for as long as the
project lives (which can be a long time). If you start a project next year, then
that project will have its own R, maybe R version 4.4.2 or something like that,
and the set of required R packages that would be current at that time. This is
because Nix always installs the software that you need in separate, (isolated)
environments on your computer. So you can define an environment for one specific
project.&lt;/p&gt;
&lt;p&gt;But Nix even goes even further: not only can you install R and R packages using
Nix (in isolated) project-specific environments, Nix even installs the required
system dependencies. So for example if I need &lt;code&gt;{rJava}&lt;/code&gt;, Nix will make sure to
install the correct version of Java as well, always in that project-specific
environment (so if you already some Java version installed on your system, there
won’t be any interference).&lt;/p&gt;
&lt;p&gt;What’s also pretty awesome, is that you can use a specific version of &lt;code&gt;nixpkgs&lt;/code&gt;
to &lt;em&gt;always&lt;/em&gt; get &lt;em&gt;exactly&lt;/em&gt; the same versions of &lt;strong&gt;all&lt;/strong&gt; the software whenever you
build that environment to run your project’s code. The environment gets defined
in a simple plain-text file, and anyone using that file to build the environment
will get exactly, byte by byte, the same environment as you when you initially
started the project. And this also regardless of the operating system that is
used.&lt;/p&gt;
&lt;p&gt;So let me illustrate this. After &lt;a href=&#34;https://nix.dev/tutorials/install-nix&#34;&gt;installing
Nix&lt;/a&gt;, I can define an environment by
writing a file called &lt;code&gt;default.nix&lt;/code&gt; that looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ pkgs ? import (fetchTarball &amp;quot;https://github.com/NixOS/nixpkgs/archive/e11142026e2cef35ea52c9205703823df225c947.tar.gz&amp;quot;) {} }:

with pkgs;

let
  my-pkgs = rWrapper.override {
    packages = with rPackages; [ dplyr ggplot2 R];
  };
in
mkShell {
  buildInputs = [my-pkgs];
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now this certainly looks complicated! And it is. The entry cost to Nix is quite
high, because, actually, Nix is more than a package manager. It is also a
programming language, and this programming language gets used to configure
environments. I won’t go too much into detail, but you’ll see in the first line
that I’m using a specific version of &lt;code&gt;nixpkgs&lt;/code&gt; that gets downloaded directly
from Github. This means that all the software that I will install with that
specific version of &lt;code&gt;nixpkgs&lt;/code&gt; will always install the same software. This is
what ensures that R and R packages are versioned. Basically, by using a specific
version of &lt;code&gt;nixpkgs&lt;/code&gt;, I pin all the versions of all the software that this
particular version of Nix will &lt;em&gt;ever&lt;/em&gt; install. I then define a variable called
&lt;code&gt;my-pkgs&lt;/code&gt; which lists the packages I want to install (&lt;code&gt;{dplyr}&lt;/code&gt;, &lt;code&gt;{ggplot2}&lt;/code&gt; and
&lt;code&gt;R&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;By the way, this may look like it would take a lot of time to install because,
after all, you need to install R, R packages and underlying system dependencies,
but thankfully there is an online cache of binaries that gets automatically used
by Nix (&lt;a href=&#34;https://cache.nixos.org/&#34;&gt;cache.nixos.org&lt;/a&gt;) for fast installations. If
binaries are not available, sources get compiled.&lt;/p&gt;
&lt;p&gt;I can now create an environment with these exact specifications using (in the
directory where &lt;code&gt;default.nix&lt;/code&gt; is):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nix-build&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or I could use the R version from this environment to run some arbitrary code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nix-shell /home/renv/default.nix --run &amp;quot;Rscript -e &amp;#39;sessionInfo()&amp;#39;&amp;quot; &amp;gt;&amp;gt; /home/renv/sessionInfo.txt&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(assuming my &lt;code&gt;default.nix&lt;/code&gt; file is available in the &lt;code&gt;/home/renv/&lt;/code&gt; directory).
This would build the environment on the fly and run &lt;code&gt;sessionInfo()&lt;/code&gt; inside of
it. Here are the contents of this &lt;code&gt;sessionInfo.txt&lt;/code&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;R version 4.2.3 (2023-03-15)
Platform: x86_64-pc-linux-gnu (64-bit)

Matrix products: default
BLAS/LAPACK: /nix/store/pbfs53rcnrzgjiaajf7xvwrfqq385ykv-blas-3/lib/libblas.so.3

locale:
[1] C

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

loaded via a namespace (and not attached):
[1] compiler_4.2.3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This looks like any other output of the &lt;code&gt;sessionInfo()&lt;/code&gt; function, but there is
something quite unusual: the &lt;code&gt;BLAS/LAPACK&lt;/code&gt; line:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BLAS/LAPACK: /nix/store/pbfs53rcnrzgjiaajf7xvwrfqq385ykv-blas-3/lib/libblas.so.3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;BLAS is a library that R uses for linear algebra, matrix multiplication and
vector operations. R usually ships with its own version of BLAS and LAPACK, but
it’s also possible to use external ones. Here, we see that the path to the
shared object &lt;code&gt;libblas.so.3&lt;/code&gt; is somewhere in &lt;code&gt;/nix/store/....&lt;/code&gt;. &lt;code&gt;/nix/store/&lt;/code&gt; is
where all the software gets installed. The long chain of seemingly random
characters is a hash, essentially the unique identifier of that particular
version of BLAS. This means that unlike Docker, if you’re using Nix you are also
certain than these types of dependencies, that may have an impact on your
results, also get handled properly, and that the exact same version you used
will keep getting installed in the future. Docker images also evolve, and even
if you use an LTS release of Ubuntu as a base, the underlying system packages
will evolve through time as well. And there will be a point in time where this
release will be abandoned (LTS releases receive 5 years of support), so if you
need to rebuild a Docker images based on an LTS that doesn’t get supported
anymore, you’re out of luck.&lt;/p&gt;
&lt;p&gt;If you don’t want to install Nix just yet on your computer, you should know that
there’s also a complete operating system called NixOS, that uses Nix as its
package manager, and that there are Docker images that use NixOS as a base. So
this means that you could use such an image and then build the environment (that
is 100% completely reproducible) inside and run a container that will always
produce the same output. To see an example of this, check out this &lt;a href=&#34;https://github.com/b-rodrigues/nix_experiments/tree/master&#34;&gt;Github
repo&lt;/a&gt;. I’m writing a
Dockerfile as I usually do, but actually I could even use Nix to define the
Docker image for me, it’s that powerful!&lt;/p&gt;
&lt;p&gt;Nix seems like a very powerful tool to me. But there are some “issues”:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;As I stated above, the entry cost is quite high, because Nix is not “just a tool”, it’s a complete programming language that can even run pipelines, so you could technically even replace something like &lt;code&gt;{targets}&lt;/code&gt; with it;&lt;/li&gt;
&lt;li&gt;If you need to install specific versions of R packages, that are not pinned to dates, then Nix is not for you. Nix will always create a coherent environment with R and R packages that go together for a particular release of &lt;code&gt;nixpkgs&lt;/code&gt;. If for some reason you need a very old version of &lt;code&gt;{ggplot2}&lt;/code&gt; but a much more recent version of &lt;code&gt;{dplyr}&lt;/code&gt;, using Nix won’t make this any easier than other methods;&lt;/li&gt;
&lt;li&gt;There is no easy way (afaik) to find the version of &lt;code&gt;nixpkgs&lt;/code&gt; that you need to download to find the version of R that you may need; &lt;strong&gt;UPDATE&lt;/strong&gt;: turns out that there is such a &lt;a href=&#34;https://lazamar.co.uk/nix-versions/?channel=nixpkgs-unstable&amp;amp;package=r&#34;&gt;simple tool&lt;/a&gt;, thanks to &lt;span class=&#34;citation&#34;&gt;@shane&lt;/span&gt;&lt;span class=&#34;citation&#34;&gt;@hachyderm.io&lt;/span&gt; for the telling me!&lt;/li&gt;
&lt;li&gt;R packages (and I guess others for other programming languages as well) that are available on the stable channel of &lt;code&gt;nixpkgs&lt;/code&gt; lag a bit behind their counterparts on CRAN. These usually all get updated whenever there’s a new release of R. Currently however, R is at version 4.2.3, but R should be at version 4.3.1 on the stable branch of &lt;code&gt;nixpkgs&lt;/code&gt;. This can sometimes happen due to various reasons (there are actual human beings behind this that volunteer their time and they also have a life). There is however an “unstable” &lt;code&gt;nixpkgs&lt;/code&gt; channel that contains bleeding edge versions of R packages (and R itself) if you really need the latest versions of packages (don’t worry about the “unstable” label, from my understanding this simply means that package have not been thoroughly tested yet, but is still pretty much rock-solid);&lt;/li&gt;
&lt;li&gt;If you need something that is not on CRAN (or Bioconductor) then it’s still possible to use Nix to install these packages, but you’ll have to perform some manual configuration.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I will keep exploring Nix, and this is essentially my todo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;using my environment that I installed with Nix to work interactively;&lt;/li&gt;
&lt;li&gt;write some tool that lets me specify an R version, a list of packages and it generates a &lt;code&gt;default.nix&lt;/code&gt; file automagically (ideally it should also deal with packages only available on Github);&lt;/li&gt;
&lt;li&gt;????&lt;/li&gt;
&lt;li&gt;Profit!&lt;/li&gt;
&lt;/ul&gt;
&lt;div id=&#34;resources&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Resources&lt;/h3&gt;
&lt;p&gt;Here are some of the resources I’ve been using:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://nix.dev/tutorials/first-steps/towards-reproducibility-pinning-nixpkgs#pinning-nixpkgs&#34;&gt;nix.dev tutorials&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nix-tutorial.gitlabpages.inria.fr/nix-tutorial/installation.html&#34;&gt;INRIA’s Nix tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nixos.org/guides/nix-pills/&#34;&gt;Nix pills&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/nix-community/nix-data-science&#34;&gt;Nix for Data Science&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://christitus.com/nixos-explained/&#34;&gt;NixOS explained&lt;/a&gt;: NixOS is an entire Linux distribution that uses Nix as its package manager.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://rgoswami.me/posts/nix-r-devtools/&#34;&gt;Blog post: Nix with R and devtools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://rgoswami.me/posts/rethinking-r-nix/&#34;&gt;Blog post: Statistical Rethinking and Nix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://lazamar.github.io/download-specific-package-version-with-nix/&#34;&gt;Blog post: Searching and installing old versions of Nix packages&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;thanks&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Thanks&lt;/h3&gt;
&lt;p&gt;Many thanks to &lt;a href=&#34;https://github.com/jbedo&#34;&gt;Justin Bedő&lt;/a&gt;, maintainer of the R
package for Nix, for answering all my questions on Nix!&lt;/p&gt;
&lt;p&gt;
Hope you enjoyed! If you found this blog post useful, you might want to follow
me on &lt;a href=&#34;https://fosstodon.org/@brodriguesco&#34;&gt;Mastodon&lt;/a&gt; or &lt;a href=&#34;https://www.twitter.com/brodriguesco&#34;&gt;twitter&lt;/a&gt; for blog post updates and
&lt;a href=&#34;https://www.buymeacoffee.com/brodriguesco&#34;&gt;buy me an espresso&lt;/a&gt; or &lt;a href=&#34;https://www.paypal.me/brodriguesco&#34;&gt;paypal.me&lt;/a&gt;, or buy my &lt;a href=&#34;https://www.brodrigues.co/about/books/&#34;&gt;ebooks&lt;/a&gt;.
You can also watch my videos on &lt;a href=&#34;https://www.youtube.com/c/BrunoRodrigues1988/&#34;&gt;youtube&lt;/a&gt;.
So much content for you to consoom!
&lt;/p&gt;
&lt;style&gt;.bmc-button img{width: 27px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-flex !important;color:#ffffff !important;background-color:#272b30 !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 1px 9px !important;font-size: 22px !important;letter-spacing:0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:&#39;Cookie&#39;, cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#82518c !important;}&lt;/style&gt;
&lt;p&gt;
&lt;link href=&#34;https://fonts.googleapis.com/css?family=Cookie&#34; rel=&#34;stylesheet&#34;&gt;&lt;a class=&#34;bmc-button&#34; target=&#34;_blank&#34; href=&#34;https://www.buymeacoffee.com/brodriguesco&#34;&gt;&lt;img src=&#34;https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg&#34; alt=&#34;Buy me an Espresso&#34;&gt;&lt;span style=&#34;margin-left:5px&#34;&gt;Buy me an Espresso&lt;/span&gt;&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>